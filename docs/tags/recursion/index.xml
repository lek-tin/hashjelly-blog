<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>recursion on Hashnopolis</title>
    <link>http://www.hashnopolis.com/tags/recursion/</link>
    <description>Recent content in recursion on Hashnopolis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Hashnopolis</copyright>
    <lastBuildDate>Mon, 23 Mar 2020 22:53:23 -0700</lastBuildDate>
    
	<atom:link href="http://www.hashnopolis.com/tags/recursion/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Flatten a Multilevel Doubly Linked List</title>
      <link>http://www.hashnopolis.com/post/flatten-a-multilevel-doubly-linked-list/</link>
      <pubDate>Mon, 23 Mar 2020 22:53:23 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/flatten-a-multilevel-doubly-linked-list/</guid>
      <description>You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below.
Flatten the list so that all the nodes appear in a single-level, doubly linked list.</description>
    </item>
    
    <item>
      <title>Populating Next Right Pointers in Each Node</title>
      <link>http://www.hashnopolis.com/post/populating-next-right-pointers-in-each-node/</link>
      <pubDate>Wed, 26 Feb 2020 20:20:25 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/populating-next-right-pointers-in-each-node/</guid>
      <description>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:
struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.
Initially, all next pointers are set to NULL.</description>
    </item>
    
    <item>
      <title>Populating Next Right Pointers in Each Node II</title>
      <link>http://www.hashnopolis.com/post/populating-next-right-pointers-in-each-node-ii/</link>
      <pubDate>Wed, 26 Feb 2020 20:19:59 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/populating-next-right-pointers-in-each-node-ii/</guid>
      <description>Given a binary tree
struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.
Initially, all next pointers are set to NULL.
Follow up  You may only use constant extra space. Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</description>
    </item>
    
    <item>
      <title>Longest Increasing Subsequence</title>
      <link>http://www.hashnopolis.com/post/longest-increasing-subsequence/</link>
      <pubDate>Wed, 19 Dec 2018 10:47:57 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/longest-increasing-subsequence/</guid>
      <description>Given an unsorted array of integers, find the length of longest increasing subsequence.
Example: Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Note  There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity?  Solution Bottom-up solution:</description>
    </item>
    
    <item>
      <title>PowX N</title>
      <link>http://www.hashnopolis.com/post/powx-n/</link>
      <pubDate>Sun, 11 Nov 2018 12:40:25 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/powx-n/</guid>
      <description>Example 1 Input: 2.00000, 10 Output: 1024.00000 Example 2 Input: 2.10000, 3 Output: 9.26100 Example 3 Input: 2.00000, -2 Output: 0.25000 Explanation 2-2 = 1/22 = 1/4 = 0.25 Note  -100.0 &amp;lt; x &amp;lt; 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1]  Solution # Time: o(logN) # Space: `O(n)` class Solution: def myPow(self, x, n): &amp;#34;&amp;#34;&amp;#34; :type x: float :type n: int :rtype: float &amp;#34;&amp;#34;&amp;#34; if n &amp;gt; 0: return self.</description>
    </item>
    
    <item>
      <title>Lowest Common Ancestor of a Binary Tree</title>
      <link>http://www.hashnopolis.com/post/lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Thu, 01 Nov 2018 13:18:53 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the : “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]
 _______3______ / \ ___5__ ___1__  / \ / 6 _2 0 8 / 7 4</description>
    </item>
    
    <item>
      <title>Invert Binary Tree</title>
      <link>http://www.hashnopolis.com/post/invert-binary-tree/</link>
      <pubDate>Fri, 26 Oct 2018 23:12:09 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/invert-binary-tree/</guid>
      <description>Invert a binary tree.
 4 / \ 2 7 / \ / \ 1 3 6 9 to
 4 / \ 7 2 / \ / \ 9 6 3 1 Thoughts What if a node is NULL? A NULL has no children, so how to iterate deeper into the tree?
Solution // Attempt // class Solution { // public:  void swapNodes(*leftNode, *rightNode) { *temp = *leftNode; *leftNode = *rightNode; *rightNode = temp; return; } TreeNode* invertTree(TreeNode* root) { if (root == NULL) return invertTree(root-&amp;gt;left) } }; Solution C++</description>
    </item>
    
    <item>
      <title>Decode Ways</title>
      <link>http://www.hashnopolis.com/post/decode-ways/</link>
      <pubDate>Wed, 03 Oct 2018 23:49:00 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/decode-ways/</guid>
      <description>A message containing letters from A-Z is being encoded to numbers using the following mapping:
&amp;lsquo;A&amp;rsquo; -&amp;gt; 1 &amp;lsquo;B&amp;rsquo; -&amp;gt; 2 &amp;hellip; &amp;lsquo;Z&amp;rsquo; -&amp;gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it.
Example 1 Input: &amp;quot;12&amp;quot; Output: 2 Explanation: It could be decoded as &amp;quot;AB&amp;quot; (1 2) or &amp;quot;L&amp;quot; (12). Example 2 Input: &amp;quot;226&amp;quot; Output: 3 Explanation: It could be decoded as &amp;quot;BZ&amp;quot; (2 26), &amp;quot;VF&amp;quot; (22 6), or &amp;quot;BBF&amp;quot; (2 2 6).</description>
    </item>
    
  </channel>
</rss>