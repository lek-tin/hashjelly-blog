<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bfs on Hashnopolis</title>
    <link>http://www.hashnopolis.com/tags/bfs/</link>
    <description>Recent content in bfs on Hashnopolis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Hashnopolis</copyright>
    <lastBuildDate>Sat, 29 Feb 2020 19:39:11 -0800</lastBuildDate>
    
	<atom:link href="http://www.hashnopolis.com/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Rotting Oranges</title>
      <link>http://www.hashnopolis.com/post/2020/02/rotting-oranges/</link>
      <pubDate>Sat, 29 Feb 2020 19:39:11 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2020/02/rotting-oranges/</guid>
      <description>In a given grid, each cell can have one of three values:
 the value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange.  Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.
Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead.</description>
    </item>
    
    <item>
      <title>Treasure Island II</title>
      <link>http://www.hashnopolis.com/post/2020/02/treasure-island-ii/</link>
      <pubDate>Sat, 29 Feb 2020 17:21:45 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2020/02/treasure-island-ii/</guid>
      <description>You have a map that marks the locations of treasure islands. Some of the map area has jagged rocks and dangerous reefs. Other areas are safe to sail in. There are other explorers trying to find the treasure. So you must figure out a shortest route to one of the treasure islands.
Assume the map area is a two dimensional grid, represented by a matrix of characters. You must start from one of the starting point (marked as S) of the map and can move one block up, down, left or right at a time.</description>
    </item>
    
    <item>
      <title>Treasure Island</title>
      <link>http://www.hashnopolis.com/post/2020/02/treasure-island/</link>
      <pubDate>Sat, 29 Feb 2020 17:20:05 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2020/02/treasure-island/</guid>
      <description>You have a map that marks the location of a treasure island. Some of the map area has jagged rocks and dangerous reefs. Other areas are safe to sail in. There are other explorers trying to find the treasure. So you must figure out a shortest route to the treasure island.
Assume the map area is a two dimensional grid, represented by a matrix of characters. You must start from the top-left corner of the map and can move one block up, down, left or right at a time.</description>
    </item>
    
    <item>
      <title>Populating Next Right Pointers in Each Node</title>
      <link>http://www.hashnopolis.com/post/2020/02/populating-next-right-pointers-in-each-node/</link>
      <pubDate>Wed, 26 Feb 2020 20:20:25 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2020/02/populating-next-right-pointers-in-each-node/</guid>
      <description>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:
struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.
Initially, all next pointers are set to NULL.</description>
    </item>
    
    <item>
      <title>Populating Next Right Pointers in Each Node II</title>
      <link>http://www.hashnopolis.com/post/2020/02/populating-next-right-pointers-in-each-node-ii/</link>
      <pubDate>Wed, 26 Feb 2020 20:19:59 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2020/02/populating-next-right-pointers-in-each-node-ii/</guid>
      <description>Given a binary tree
struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.
Initially, all next pointers are set to NULL.
Follow up  You may only use constant extra space. Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</description>
    </item>
    
    <item>
      <title>Sliding Puzzle</title>
      <link>http://www.hashnopolis.com/post/2020/02/sliding-puzzle/</link>
      <pubDate>Mon, 17 Feb 2020 23:36:34 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2020/02/sliding-puzzle/</guid>
      <description>On a 2x3 board, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0.
A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.
The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].
Given a puzzle board, return the least number of moves required so that the state of the board is solved.</description>
    </item>
    
    <item>
      <title>Word Ladder II</title>
      <link>http://www.hashnopolis.com/post/2019/11/word-ladder-ii/</link>
      <pubDate>Sat, 30 Nov 2019 16:03:43 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/11/word-ladder-ii/</guid>
      <description>Given two words (beginWord and endWord), and a dictionary&amp;rsquo;s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:
 Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:  Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters.</description>
    </item>
    
    <item>
      <title>Island Perimeter</title>
      <link>http://www.hashnopolis.com/post/2019/09/island-perimeter/</link>
      <pubDate>Fri, 27 Sep 2019 16:50:11 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/09/island-perimeter/</guid>
      <description>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.
Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).
The island doesn&amp;rsquo;t have &amp;ldquo;lakes&amp;rdquo; (water inside that isn&amp;rsquo;t connected to the water around the island). One cell is a square with side length 1.</description>
    </item>
    
    <item>
      <title>Clone Graph</title>
      <link>http://www.hashnopolis.com/post/2019/08/clone-graph/</link>
      <pubDate>Sun, 11 Aug 2019 01:12:12 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/08/clone-graph/</guid>
      <description>Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.
Example: Input: {&amp;quot;$id&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$id&amp;quot;:&amp;quot;2&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;1&amp;quot;},{&amp;quot;$id&amp;quot;:&amp;quot;3&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;2&amp;quot;},{&amp;quot;$id&amp;quot;:&amp;quot;4&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;3&amp;quot;},{&amp;quot;$ref&amp;quot;:&amp;quot;1&amp;quot;}],&amp;quot;val&amp;quot;:4}],&amp;quot;val&amp;quot;:3}],&amp;quot;val&amp;quot;:2},{&amp;quot;$ref&amp;quot;:&amp;quot;4&amp;quot;}],&amp;quot;val&amp;quot;:1} Explanation: Node 1&#39;s value is 1, and it has two neighbors: Node 2 and 4. Node 2&#39;s value is 2, and it has two neighbors: Node 1 and 3. Node 3&#39;s value is 3, and it has two neighbors: Node 2 and 4.</description>
    </item>
    
    <item>
      <title>Word Search II</title>
      <link>http://www.hashnopolis.com/post/2019/04/word-search-ii/</link>
      <pubDate>Mon, 08 Apr 2019 23:50:33 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/04/word-search-ii/</guid>
      <description>Given a 2D board and a list of words from the dictionary, find all words in the board.
Each word must be constructed from letters of sequentially adjacent cell, where &amp;ldquo;adjacent&amp;rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.
Example: Input: board = [ [&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;], [&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;], [&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;], [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;] ] words = [&amp;quot;oath&amp;quot;,&amp;quot;pea&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;rain&amp;quot;] Output: [&amp;quot;eat&amp;quot;,&amp;quot;oath&amp;quot;] Note:  All inputs are consist of lowercase letters a-z.</description>
    </item>
    
    <item>
      <title>The Maze II</title>
      <link>http://www.hashnopolis.com/post/2019/03/the-maze-ii/</link>
      <pubDate>Mon, 18 Mar 2019 20:34:03 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/the-maze-ii/</guid>
      <description>There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won&amp;rsquo;t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.
Given the ball&amp;rsquo;s start position, the destination and the maze, find the shortest distance for the ball to stop at the destination. The distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to the destination (included).</description>
    </item>
    
    <item>
      <title>The Maze</title>
      <link>http://www.hashnopolis.com/post/2019/03/the-maze/</link>
      <pubDate>Sun, 17 Mar 2019 20:18:05 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/the-maze/</guid>
      <description>There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won&amp;rsquo;t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.
Given the ball&amp;rsquo;s start position, the destination and the maze, determine whether the ball could stop at the destination.
The maze is represented by a binary 2D array.</description>
    </item>
    
    <item>
      <title>Snakes and Ladders</title>
      <link>http://www.hashnopolis.com/post/2019/03/snakes-and-ladders/</link>
      <pubDate>Tue, 12 Mar 2019 01:16:31 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/snakes-and-ladders/</guid>
      <description>On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row. For example, for a 6 x 6 board, the numbers are written as follows: You start on square 1 of the board (which is always in the last row and first column). Each move, starting from square x, consists of the following:</description>
    </item>
    
    <item>
      <title>Binary Tree Zigzag Level Order Traversal</title>
      <link>http://www.hashnopolis.com/post/2019/01/binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Fri, 25 Jan 2019 00:12:07 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/binary-tree-zigzag-level-order-traversal/</guid>
      <description>Given a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, then right to left for the next level and alternate between).
Example Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7 return its zigzag level order traversal as:
[ [3], [20,9], [15,7] ] Solution # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Validate Binary Search Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/validate-binary-search-tree/</link>
      <pubDate>Sat, 10 Nov 2018 22:50:21 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/validate-binary-search-tree/</guid>
      <description>Given a binary tree, determine if it is a valid binary search tree (BST).
Assume a BST is defined as follows:
 The left subtree of a node contains only nodes with keys less than the node&amp;rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node&amp;rsquo;s key. Both the left and right subtrees must also be binary search trees.  Example 1 Input: 2 / \ 1 3 Output: true Example 2  5 / \ 1 4 / \ 3 6 Output: false Explanation The input is: [5,1,4,null,null,3,6].</description>
    </item>
    
    <item>
      <title>Word Ladder</title>
      <link>http://www.hashnopolis.com/post/2018/10/word-ladder/</link>
      <pubDate>Sat, 27 Oct 2018 01:05:07 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/word-ladder/</guid>
      <description>Given two words (beginWord and endWord), and a dictionary&amp;rsquo;s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:
 Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note  Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters.</description>
    </item>
    
    <item>
      <title>Word Break</title>
      <link>http://www.hashnopolis.com/post/2018/10/word-break/</link>
      <pubDate>Wed, 10 Oct 2018 23:57:15 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/word-break/</guid>
      <description>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.
Note  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1 Input: s = &amp;quot;leetcode&amp;quot;, wordDict = [&amp;quot;leet&amp;quot;, &amp;quot;code&amp;quot;] Output: true Explanation: Return true because &amp;quot;leetcode&amp;quot; can be segmented as &amp;quot;leet code&amp;quot;.</description>
    </item>
    
    <item>
      <title>Number of Islands</title>
      <link>http://www.hashnopolis.com/post/2018/10/number-of-islands/</link>
      <pubDate>Tue, 09 Oct 2018 23:52:32 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/number-of-islands/</guid>
      <description>Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
Example 1 Input: 11110 11010 11000 00000 Output: 1 Example 2 Input: 11000 11000 00100 00011 Output: 3 DFS
Solution class Solution: def numIslands(self, grid): &amp;#34;&amp;#34;&amp;#34; :type grid: List[List[str]] :rtype: int &amp;#34;&amp;#34;&amp;#34; # Edge cases if not grid or len(grid) == 0 or len(grid[0]) == 0: return 0 rows = len(grid) cols = len(grid[0]) count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == &amp;#34;1&amp;#34;: count += 1 self.</description>
    </item>
    
  </channel>
</rss>