<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Binary Tree on Hashnopolis</title>
    <link>http://www.hashnopolis.com/tags/binary-tree/</link>
    <description>Recent content in Binary Tree on Hashnopolis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Hashnopolis</copyright>
    <lastBuildDate>Sun, 30 Dec 2018 22:43:56 -0800</lastBuildDate>
    
	<atom:link href="http://www.hashnopolis.com/tags/binary-tree/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Binary Tree Vertical Order Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/12/binary-tree-vertical-order-traversal/</link>
      <pubDate>Sun, 30 Dec 2018 22:43:56 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/12/binary-tree-vertical-order-traversal/</guid>
      <description>Given a binary tree, return the vertical order traversal of its nodes&amp;rsquo; values. (ie, from top to bottom, column by column).
If two nodes are in the same row and column, the order should be from left to right.
Examples 1:
Input: [3,9,20,null,null,15,7] 3 /\ / \ 9 20 /\ / \ 15 7 Output: [ [9], [3,15], [20], [7] ]  Examples 2:
Input: [3,9,8,4,0,1,7] 3 /\ / \ 9 8 /\ /\ / \/ \ 4 01 7 Output: [ [4], [9], [3,0,1], [8], [7] ]  Examples 3:</description>
    </item>
    
    <item>
      <title>Serialize and Deserialize Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/serialize-and-deserialize-binary-tree/</link>
      <pubDate>Tue, 13 Nov 2018 17:31:13 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/serialize-and-deserialize-binary-tree/</guid>
      <description>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</description>
    </item>
    
    <item>
      <title>Lowest Common Ancestor of a Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Thu, 01 Nov 2018 13:18:53 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the : “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]
 _______3______ / \ ___5__ ___1__  / \ / 6 _2 0 8 / 7 4 Example 1:</description>
    </item>
    
    <item>
      <title>Invert Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2018/10/invert-binary-tree/</link>
      <pubDate>Fri, 26 Oct 2018 23:12:09 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/invert-binary-tree/</guid>
      <description>Invert a binary tree.
 4 / \ 2 7 / \ / \ 1 3 6 9  to
 4 / \ 7 2 / \ / \ 9 6 3 1  Thoughts What if a node is NULL? A NULL has no children, so how to iterate deeper into the tree?
// Attempt // class Solution { // public: void swapNodes(*leftNode, *rightNode) { *temp = *leftNode; *leftNode = *rightNode; *rightNode = temp; return; } TreeNode* invertTree(TreeNode* root) { if (root == NULL) return invertTree(root-&amp;gt;left, ) } };  Solution:</description>
    </item>
    
    <item>
      <title>Merge Two Binary Trees</title>
      <link>http://www.hashnopolis.com/post/2018/10/merge-two-binary-trees/</link>
      <pubDate>Thu, 25 Oct 2018 23:42:27 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/merge-two-binary-trees/</guid>
      <description>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.
You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</description>
    </item>
    
    <item>
      <title>Kth Smallest Element in a BST</title>
      <link>http://www.hashnopolis.com/post/2018/10/kth-smallest-element-in-a-bst/</link>
      <pubDate>Wed, 24 Oct 2018 23:39:48 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/kth-smallest-element-in-a-bst/</guid>
      <description>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.
Note:
You may assume k is always valid, 1 ≤ k ≤ BST&#39;s total elements.  Example 1:
Input: root = [3,1,4,null,2], k = 1 Output: 1  Example 2: ```` Input: root = [5,3,6,2,4,null,null,1], k = 3 Output: 3
**Follow up:** What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently?</description>
    </item>
    
    <item>
      <title>Binary Tree Maximum Path Sum</title>
      <link>http://www.hashnopolis.com/post/2018/10/binary-tree-maximum-path-sum/</link>
      <pubDate>Tue, 09 Oct 2018 23:50:03 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/binary-tree-maximum-path-sum/</guid>
      <description>Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
Example 1:
Input: [1,2,3] 1 / \ 2 3 Output: 6  Example 2:
Input: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7 Output: 42  Solution:</description>
    </item>
    
    <item>
      <title>Symmetric Tree</title>
      <link>http://www.hashnopolis.com/post/2018/09/symmetric-tree/</link>
      <pubDate>Sun, 16 Sep 2018 15:05:12 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/symmetric-tree/</guid>
      <description>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
For example, this binary tree [1,2,2,3,4,4,3] is symmetric:
 1 / \ 2 2 / \ / \ 3 4 4 3  But the following [1,2,2,null,3,null,3] is not:
 1 / \ 2 2 \ \ 3 3  Note: Bonus points if you could solve it both recursively and iteratively.
Solution:</description>
    </item>
    
    <item>
      <title>Same Tree</title>
      <link>http://www.hashnopolis.com/post/2018/09/same-tree/</link>
      <pubDate>Sun, 16 Sep 2018 15:03:53 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/same-tree/</guid>
      <description>Given two binary trees, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical and the nodes have the same value.
Example 1:
Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] Output: true  Example 2:
Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false  Example 3:
Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2] Output: false  Solution</description>
    </item>
    
    <item>
      <title>Swap Nodes in Pairs</title>
      <link>http://www.hashnopolis.com/post/2018/09/swap-nodes-in-pairs/</link>
      <pubDate>Sat, 15 Sep 2018 12:55:20 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/swap-nodes-in-pairs/</guid>
      <description>Given a linked list, swap every two adjacent nodes and return its head.
Example:
Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.  Note: - Your algorithm should use only constant extra space. - You may not modify the values in the list&amp;rsquo;s nodes, only nodes itself may be changed. Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def swapPairs(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; # https://www.</description>
    </item>
    
    <item>
      <title>Binary Tree Right Side View</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-right-side-view/</link>
      <pubDate>Thu, 13 Sep 2018 23:03:06 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-right-side-view/</guid>
      <description>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.
Example:
Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 &amp;lt;--- / \ 2 3 &amp;lt;--- \ \ 5 4 &amp;lt;---  Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.</description>
    </item>
    
    <item>
      <title>Binary Tree Preorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-preorder-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 23:02:11 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-preorder-traversal/</guid>
      <description>Given a binary tree, return the preorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,2,3]  Follow up: Recursive solution is trivial, could you do it iteratively?
Solution:
# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def preorderTraversal_1(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; if root is None: return [] return [root.</description>
    </item>
    
    <item>
      <title>Binary Tree Postorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-postorder-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 23:01:30 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-postorder-traversal/</guid>
      <description>Given a binary tree, return the postorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [3,2,1]  Follow up:
Recursive solution is trivial, could you do it iteratively?
Solution:
Recursive👇
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def postorderTraversal(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; def traverse(node): if node == None: return [] return traverse(node.</description>
    </item>
    
    <item>
      <title>Binary Tree Paths</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-paths/</link>
      <pubDate>Thu, 13 Sep 2018 23:00:42 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-paths/</guid>
      <description>Given a binary tree, return all root-to-leaf paths.
Note: A leaf is a node with no children.
Example:
Input: 1 / \ 2 3 \ 5 Output: [&amp;quot;1-&amp;gt;2-&amp;gt;5&amp;quot;, &amp;quot;1-&amp;gt;3&amp;quot;]  Explanation: All root-to-leaf paths are: 1-&amp;gt;2-&amp;gt;5, 1-&amp;gt;3
Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def binaryTreePaths(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[str] &amp;quot;&amp;quot;&amp;quot; res = [] def traverse(root, path): if root == None: return path += str(root.</description>
    </item>
    
    <item>
      <title>Binary Tree Level Order Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 22:59:49 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal/</guid>
      <description>Given a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level).
For example:
Given binary tree `[3,9,20,null,null,15,7]`, 3 / \ 9 20 / \ 15 7  return its level order traversal as:
[ [3], [9,20], [15,7] ]  Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.</description>
    </item>
    
    <item>
      <title>Binary Tree Level Order Traversal II</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal-ii/</link>
      <pubDate>Thu, 13 Sep 2018 22:59:17 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal-ii/</guid>
      <description>Given a binary tree, return the bottom-up level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level from leaf to root).
For example: Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  return its bottom-up level order traversal as:
[ [15,7], [9,20], [3] ]  Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Binary Tree Inorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-inorder-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 22:57:42 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-inorder-traversal/</guid>
      <description>Given a binary tree, return the inorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,3,2]  Follow up: the Recursive solution is trivial, could you do it iteratively?
Solution
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def inorderTraversal(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot;Check root == None to reduce time on checking&amp;quot;&amp;quot;&amp;quot; if root == None: return [] stack = [] result = [] current = root while (current!</description>
    </item>
    
    <item>
      <title>Binary Search Tree Iterator</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-search-tree-iterator/</link>
      <pubDate>Sun, 09 Sep 2018 15:15:09 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-search-tree-iterator/</guid>
      <description>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.
Calling next() will return the next smallest number in the BST.
Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
Solution:
# Definition for a binary tree node # class TreeNode(object): # def __init__(self, x): # self.</description>
    </item>
    
  </channel>
</rss>