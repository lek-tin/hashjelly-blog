<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dfs on Hashnopolis</title>
    <link>http://www.hashnopolis.com/tags/dfs/</link>
    <description>Recent content in dfs on Hashnopolis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Hashnopolis</copyright>
    <lastBuildDate>Sun, 15 Mar 2020 04:42:35 -0700</lastBuildDate>
    
	<atom:link href="http://www.hashnopolis.com/tags/dfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Scramble String</title>
      <link>http://www.hashnopolis.com/post/2020/03/scramble-string/</link>
      <pubDate>Sun, 15 Mar 2020 04:42:35 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2020/03/scramble-string/</guid>
      <description>Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.
Below is one possible representation of s1 = &amp;quot;great&amp;quot;:
 great / \ gr eat / \ / \ g r e at / \ a t To scramble the string, we may choose any non-leaf node and swap its two children.
For example, if we choose the node &amp;quot;gr&amp;quot; and swap its two children, it produces a scrambled string &amp;quot;rgeat&amp;quot;.</description>
    </item>
    
    <item>
      <title>Combination Sum Iv</title>
      <link>http://www.hashnopolis.com/post/2020/03/combination-sum-iv/</link>
      <pubDate>Sun, 08 Mar 2020 20:19:24 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2020/03/combination-sum-iv/</guid>
      <description>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.
Example nums = [1, 2, 3] target = 4 The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) Note that different sequences are counted as different combinations. Therefore the output is 7.</description>
    </item>
    
    <item>
      <title>Number of Islands Ii</title>
      <link>http://www.hashnopolis.com/post/2020/03/number-of-islands-ii/</link>
      <pubDate>Fri, 06 Mar 2020 20:24:47 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2020/03/number-of-islands-ii/</guid>
      <description>A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</description>
    </item>
    
    <item>
      <title>Critical Routers</title>
      <link>http://www.hashnopolis.com/post/2020/03/critical-routers/</link>
      <pubDate>Mon, 02 Mar 2020 00:18:54 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2020/03/critical-routers/</guid>
      <description>You are given an undirected connected graph. An articulation point (or cut vertex) is defined as a vertex which, when removed along with associated edges, makes the graph disconnected (or more precisely, increases the number of connected components in the graph). The task is to find all articulation points in the given graph.
Input:
The input to the function/method consists of three arguments:
 numNodes, an integer representing the number of nodes in the graph.</description>
    </item>
    
    <item>
      <title>Critical Connections</title>
      <link>http://www.hashnopolis.com/post/2020/03/critical-connections/</link>
      <pubDate>Sun, 01 Mar 2020 10:01:11 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2020/03/critical-connections/</guid>
      <description>Given an underected connected graph with n nodes labeled 1..n. A bridge (cut edge) is defined as an edge which, when removed, makes the graph disconnected (or more precisely, increases the number of connected components in the graph). Equivalently, an edge is a bridge if and only if it is not contained in any cycle. The task is to find all bridges in the given graph. Output an empty list if there are no bridges.</description>
    </item>
    
    <item>
      <title>Vertical Order Traversal of a Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2020/02/vertical-order-traversal-of-a-binary-tree/</link>
      <pubDate>Thu, 27 Feb 2020 00:48:43 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2020/02/vertical-order-traversal-of-a-binary-tree/</guid>
      <description>Given a binary tree, return the vertical order traversal of its nodes values.
For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1).
Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).</description>
    </item>
    
    <item>
      <title>Is Graph Bipartite</title>
      <link>http://www.hashnopolis.com/post/2020/02/is-graph-bipartite/</link>
      <pubDate>Fri, 21 Feb 2020 01:20:58 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2020/02/is-graph-bipartite/</guid>
      <description>Given an undirected graph, return true if and only if it is bipartite.
Recall that a graph is bipartite if we can split it&amp;rsquo;s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.
The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.</description>
    </item>
    
    <item>
      <title>Package Dependencies</title>
      <link>http://www.hashnopolis.com/post/2020/01/package-dependencies/</link>
      <pubDate>Thu, 02 Jan 2020 18:19:16 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2020/01/package-dependencies/</guid>
      <description>Solution def package_dependencies(dependencies): result = [] visiting = set([]) visited = set([]) def dfs(node): if node in visited: return visiting.add(node) for dependency in node.dependencies: if dependency in visiting: raise Exception(&amp;#34;Have cycle in dependency graph.&amp;#34;) if dependency not in visited: dfs(dependency) visiting.remove(node) visited.add(node) result.add(add) for node in dependencies: dfs(node) return result </description>
    </item>
    
    <item>
      <title>Word Ladder II</title>
      <link>http://www.hashnopolis.com/post/2019/11/word-ladder-ii/</link>
      <pubDate>Sat, 30 Nov 2019 16:03:43 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/11/word-ladder-ii/</guid>
      <description>Given two words (beginWord and endWord), and a dictionary&amp;rsquo;s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:
 Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:  Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters.</description>
    </item>
    
    <item>
      <title>Path Sum II</title>
      <link>http://www.hashnopolis.com/post/2019/11/path-sum-ii/</link>
      <pubDate>Sat, 30 Nov 2019 01:51:33 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/11/path-sum-ii/</guid>
      <description>Given a binary tree and a sum, find all root-to-leaf paths where each path&amp;rsquo;s sum equals the given sum.
Note: A leaf is a node with no children.
Example: Given the below binary tree and sum = 22,
 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 Return:
[ [5,4,11,2], [5,8,4,5] ] Solution # Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Path Sum</title>
      <link>http://www.hashnopolis.com/post/2019/10/path-sum/</link>
      <pubDate>Sat, 12 Oct 2019 17:43:14 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/10/path-sum/</guid>
      <description>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
Note: A leaf is a node with no children.
Example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.</description>
    </item>
    
    <item>
      <title>Convert Sorted List to Binary Search Tree</title>
      <link>http://www.hashnopolis.com/post/2019/10/convert-sorted-list-to-binary-search-tree/</link>
      <pubDate>Wed, 09 Oct 2019 23:51:44 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/10/convert-sorted-list-to-binary-search-tree/</guid>
      <description>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
Example: Given the sorted linked list: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 Solution python</description>
    </item>
    
    <item>
      <title>Strobogrammatic Number II</title>
      <link>http://www.hashnopolis.com/post/2019/10/strobogrammatic-number-ii/</link>
      <pubDate>Wed, 02 Oct 2019 23:49:15 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/10/strobogrammatic-number-ii/</guid>
      <description>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).
Find all strobogrammatic numbers that are of length = n.
Example: Input: n = 2 Output: [&amp;quot;11&amp;quot;,&amp;quot;69&amp;quot;,&amp;quot;88&amp;quot;,&amp;quot;96&amp;quot;] Solution # Time: O(n^2 * 5^(n/2)) # Space: `O(n)` class Solution: def findStrobogrammatic(self, n: int) -&amp;gt; List[str]: stroboPairs = { &amp;#34;0&amp;#34;: &amp;#34;0&amp;#34;, &amp;#34;1&amp;#34;: &amp;#34;1&amp;#34;, &amp;#34;6&amp;#34;: &amp;#34;9&amp;#34;, &amp;#34;8&amp;#34;: &amp;#34;8&amp;#34;, &amp;#34;9&amp;#34;: &amp;#34;6&amp;#34; } return self.build(stroboPairs, n, n) def build(self, stroboPairs, curr, n): if curr == 0: return [&amp;#34;&amp;#34;] if curr == 1: return list(&amp;#34;018&amp;#34;) prev = self.</description>
    </item>
    
    <item>
      <title>Clone Graph</title>
      <link>http://www.hashnopolis.com/post/2019/08/clone-graph/</link>
      <pubDate>Sun, 11 Aug 2019 01:12:12 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/08/clone-graph/</guid>
      <description>Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.
Example: Input: {&amp;quot;$id&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$id&amp;quot;:&amp;quot;2&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;1&amp;quot;},{&amp;quot;$id&amp;quot;:&amp;quot;3&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;2&amp;quot;},{&amp;quot;$id&amp;quot;:&amp;quot;4&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;3&amp;quot;},{&amp;quot;$ref&amp;quot;:&amp;quot;1&amp;quot;}],&amp;quot;val&amp;quot;:4}],&amp;quot;val&amp;quot;:3}],&amp;quot;val&amp;quot;:2},{&amp;quot;$ref&amp;quot;:&amp;quot;4&amp;quot;}],&amp;quot;val&amp;quot;:1} Explanation: Node 1&#39;s value is 1, and it has two neighbors: Node 2 and 4. Node 2&#39;s value is 2, and it has two neighbors: Node 1 and 3. Node 3&#39;s value is 3, and it has two neighbors: Node 2 and 4.</description>
    </item>
    
    <item>
      <title>Combination Sum II</title>
      <link>http://www.hashnopolis.com/post/2019/08/combination-sum-ii/</link>
      <pubDate>Tue, 06 Aug 2019 00:57:28 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/08/combination-sum-ii/</guid>
      <description>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.
Each number in candidates may only be used once in the combination.
Note All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.
Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] ###Example 2:</description>
    </item>
    
    <item>
      <title>Generate Parentheses</title>
      <link>http://www.hashnopolis.com/post/2019/07/generate-parentheses/</link>
      <pubDate>Mon, 22 Jul 2019 23:08:05 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/07/generate-parentheses/</guid>
      <description>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
For example, given n = 3, a solution set is:
[ &amp;quot;((()))&amp;quot;, &amp;quot;(()())&amp;quot;, &amp;quot;(())()&amp;quot;, &amp;quot;()(())&amp;quot;, &amp;quot;()()()&amp;quot; ] Solution class Solution: def generateParenthesis(self, n: int) -&amp;gt; List[str]: &amp;#34;&amp;#34;&amp;#34; :type n: int :rtype: List[str] &amp;#34;&amp;#34;&amp;#34; ans = [] self.dfs(ans, &amp;#39;&amp;#39;, 0, 0, n) return ans def dfs(self, ans, S, left, right, n): if len(S) == 2 * n: ans.</description>
    </item>
    
    <item>
      <title>Boundary of Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2019/03/boundary-of-binary-tree/</link>
      <pubDate>Sun, 10 Mar 2019 23:31:42 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/boundary-of-binary-tree/</guid>
      <description>Given a binary tree, return the values of its boundary in anti-clockwise direction starting from root. Boundary includes left boundary, leaves, and right boundary in order without duplicate nodes.
Left boundary is defined as the path from root to the left-most node. Right boundary is defined as the path from root to the right-most node. If the root doesn&amp;rsquo;t have left subtree or right subtree, then the root itself is left boundary or right boundary.</description>
    </item>
    
    <item>
      <title>Diameter of Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2019/03/diameter-of-binary-tree/</link>
      <pubDate>Sat, 09 Mar 2019 18:50:51 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/diameter-of-binary-tree/</guid>
      <description>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.
Example: Given a binary tree 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</description>
    </item>
    
    <item>
      <title>Number of Connected Components in an Undirected Graph</title>
      <link>http://www.hashnopolis.com/post/2019/03/number-of-connected-components-in-an-undirected-graph/</link>
      <pubDate>Thu, 07 Mar 2019 11:40:26 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/number-of-connected-components-in-an-undirected-graph/</guid>
      <description>Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.
Example 1: Input: n = 5 and edges = [[0, 1], [1, 2], [3, 4]] 0 3 | | 1 --- 2 4 Output: 2 Example 2: Input: n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]] 0 4 | | 1 --- 2 --- 3 Output: 1 Note: You can assume that no duplicate edges will appear in edges.</description>
    </item>
    
    <item>
      <title>House Robber III</title>
      <link>http://www.hashnopolis.com/post/2019/02/house-robber-iii/</link>
      <pubDate>Thu, 21 Feb 2019 20:56:55 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/house-robber-iii/</guid>
      <description>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the &amp;ldquo;root.&amp;rdquo; Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that &amp;ldquo;all houses in this place forms a binary tree&amp;rdquo;. It will automatically contact the police if two directly-linked houses were broken into on the same night.
Determine the maximum amount of money the thief can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title>Binary Tree Zigzag Level Order Traversal</title>
      <link>http://www.hashnopolis.com/post/2019/01/binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Fri, 25 Jan 2019 00:12:07 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/binary-tree-zigzag-level-order-traversal/</guid>
      <description>Given a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, then right to left for the next level and alternate between).
Example Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7 return its zigzag level order traversal as:
[ [3], [20,9], [15,7] ] Solution # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Course Schedule</title>
      <link>http://www.hashnopolis.com/post/2018/12/course-schedule/</link>
      <pubDate>Sun, 09 Dec 2018 23:29:18 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/12/course-schedule/</guid>
      <description>There are a total of n courses you have to take, labeled from 0 to n-1.
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?
Example 1 Input: 2, [[1,0]] Output: true Explanation: There are a total of 2 courses to take.</description>
    </item>
    
    <item>
      <title>Word Break II</title>
      <link>http://www.hashnopolis.com/post/2018/11/word-break-ii/</link>
      <pubDate>Thu, 29 Nov 2018 00:00:35 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/word-break-ii/</guid>
      <description>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.
Note  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1 Input: s = &amp;quot;catsanddog&amp;quot; wordDict = [&amp;quot;cat&amp;quot;, &amp;quot;cats&amp;quot;, &amp;quot;and&amp;quot;, &amp;quot;sand&amp;quot;, &amp;quot;dog&amp;quot;] Output: [ &amp;quot;cats and dog&amp;quot;, &amp;quot;cat sand dog&amp;quot; ] Example 2 Input: s = &amp;quot;pineapplepenapple&amp;quot; wordDict = [&amp;quot;apple&amp;quot;, &amp;quot;pen&amp;quot;, &amp;quot;applepen&amp;quot;, &amp;quot;pine&amp;quot;, &amp;quot;pineapple&amp;quot;] Output: [ &amp;quot;pine apple pen apple&amp;quot;, &amp;quot;pineapple pen apple&amp;quot;, &amp;quot;pine applepen apple&amp;quot; ] Explanation: Note that you are allowed to reuse a dictionary word.</description>
    </item>
    
    <item>
      <title>Remove Invalid Parentheses</title>
      <link>http://www.hashnopolis.com/post/2018/11/remove-invalid-parentheses/</link>
      <pubDate>Tue, 13 Nov 2018 16:20:10 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/remove-invalid-parentheses/</guid>
      <description>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.
Note The input string may contain letters other than the parentheses ( and ). *### Example 1
Input: &amp;quot;()())()&amp;quot; Output: [&amp;quot;()()()&amp;quot;, &amp;quot;(())()&amp;quot;] *### Example 2
Input: &amp;quot;(a)())()&amp;quot; Output: [&amp;quot;(a)()()&amp;quot;, &amp;quot;(a())()&amp;quot;] *### Example 3
Input: &amp;quot;)(&amp;quot; Output: [&amp;quot;&amp;quot;] *### Solution
# Credit: # Credit: https://leetcode.com/problems/remove-invalid-parentheses/discuss/186597/Very-easy-to-understand-Python-DFS class Solution(object): def removeInvalidParentheses(self, s): &amp;#34;&amp;#34;&amp;#34; :type s: str :rtype: List[str] &amp;#34;&amp;#34;&amp;#34; res = [] self.</description>
    </item>
    
    <item>
      <title>Add and Search Word Data Structure Design</title>
      <link>http://www.hashnopolis.com/post/2018/11/add-and-search-word-data-structure-design/</link>
      <pubDate>Thu, 08 Nov 2018 22:37:27 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/add-and-search-word-data-structure-design/</guid>
      <description>Design a data structure that supports the following two operations:
void addWord(word) bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.
Example addWord(&amp;quot;bad&amp;quot;) addWord(&amp;quot;dad&amp;quot;) addWord(&amp;quot;mad&amp;quot;) search(&amp;quot;pad&amp;quot;) -&amp;gt; false search(&amp;quot;bad&amp;quot;) -&amp;gt; true search(&amp;quot;.ad&amp;quot;) -&amp;gt; true search(&amp;quot;b..&amp;quot;) -&amp;gt; true Note You may assume that all words are consist of lowercase letters a-z.
Solution </description>
    </item>
    
    <item>
      <title>Lowest Common Ancestor of a Binary Search Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-search-tree/</link>
      <pubDate>Thu, 01 Nov 2018 13:23:27 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-search-tree/</guid>
      <description>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5]</description>
    </item>
    
    <item>
      <title>Lowest Common Ancestor of a Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Thu, 01 Nov 2018 13:18:53 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the : “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]
 _______3______ / \ ___5__ ___1__  / \ / 6 _2 0 8 / 7 4</description>
    </item>
    
    <item>
      <title>Word Search</title>
      <link>http://www.hashnopolis.com/post/2018/10/word-search/</link>
      <pubDate>Mon, 15 Oct 2018 23:48:28 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/word-search/</guid>
      <description>Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where &amp;ldquo;adjacent&amp;rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
Example board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] Given word = &amp;quot;ABCCED&amp;quot;, return true. Given word = &amp;quot;SEE&amp;quot;, return true. Given word = &amp;quot;ABCB&amp;quot;, return false.</description>
    </item>
    
    <item>
      <title>Number of Islands</title>
      <link>http://www.hashnopolis.com/post/2018/10/number-of-islands/</link>
      <pubDate>Tue, 09 Oct 2018 23:52:32 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/number-of-islands/</guid>
      <description>Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
Example 1 Input: 11110 11010 11000 00000 Output: 1 Example 2 Input: 11000 11000 00100 00011 Output: 3 DFS
Solution class Solution: def numIslands(self, grid): &amp;#34;&amp;#34;&amp;#34; :type grid: List[List[str]] :rtype: int &amp;#34;&amp;#34;&amp;#34; # Edge cases if not grid or len(grid) == 0 or len(grid[0]) == 0: return 0 rows = len(grid) cols = len(grid[0]) count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == &amp;#34;1&amp;#34;: count += 1 self.</description>
    </item>
    
    <item>
      <title>Binary Tree Maximum Path Sum</title>
      <link>http://www.hashnopolis.com/post/2018/10/binary-tree-maximum-path-sum/</link>
      <pubDate>Tue, 09 Oct 2018 23:50:03 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/binary-tree-maximum-path-sum/</guid>
      <description>Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
Example 1 Input: [1,2,3] 1 / \ 2 3 Output: 6 Example 2 Input: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7 Output: 42 Solution # Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Subsets II</title>
      <link>http://www.hashnopolis.com/post/2018/10/subsets-ii/</link>
      <pubDate>Mon, 08 Oct 2018 13:04:14 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/subsets-ii/</guid>
      <description>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).
Note The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] Solution Time: O(n * 2^n)
Space: O(n * 2^n) keep all the subsets of length N, since each of N elements could be present or absent.
class Solution: def subsetsWithDup(self, nums: List[int]) -&amp;gt; List[List[int]]: results = [] subset = [] # Edge case 1 if nums == None: return results # Edge case 2 if len(nums) == 0: results.</description>
    </item>
    
    <item>
      <title>Subsets</title>
      <link>http://www.hashnopolis.com/post/2018/09/subsets/</link>
      <pubDate>Sat, 15 Sep 2018 12:48:42 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/subsets/</guid>
      <description>Given a set of distinct integers, nums, return all possible subsets (the power set).
Note The solution set must not contain duplicate subsets. Example Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] Solution Time: O(n * 2^n)
Space: O(n * 2^n) keep all the subsets of length N, since each of N elements could be present or absent.
class Solution: def subsets(self, nums: List[int]) -&amp;gt; List[List[int]]: results = [] subset = [] # Edge case 1 if nums == None: return results # Edge case 2 if len(nums) == 0: results.</description>
    </item>
    
    <item>
      <title>Combination Sum III</title>
      <link>http://www.hashnopolis.com/post/2018/09/combination-sum-iii/</link>
      <pubDate>Mon, 10 Sep 2018 21:42:37 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/combination-sum-iii/</guid>
      <description>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.
Note:
All numbers will be positive integers. The solution set must not contain duplicate combinations.
Example 1 Input: k = 3, n = 7 Output: [[1,2,4]] Example 2 Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]] Solution class Solution: def combinationSum3(self, k: int, n: int) -&amp;gt; List[List[int]]: # Equivalent to subsets results = [] combination = [] # Start DFS self.</description>
    </item>
    
    <item>
      <title>Combination Sum</title>
      <link>http://www.hashnopolis.com/post/2018/09/combination-sum/</link>
      <pubDate>Mon, 10 Sep 2018 21:42:01 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/combination-sum/</guid>
      <description>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.
The same repeated number may be chosen from candidates unlimited number of times.
Note All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.
Example 1 Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ] Example 2 Input: candidates = [2,3,5], target = 8, A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ] Solution class Solution: def combinationSum(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]: # Equivalent to subsets results = [] combination = [] # Edge cases if candidates == None: return results if len(candidates) == 0: results.</description>
    </item>
    
    <item>
      <title>17. Letter Combinations of a Phone Number</title>
      <link>http://www.hashnopolis.com/post/2018/09/17.-letter-combinations-of-a-phone-number/</link>
      <pubDate>Mon, 03 Sep 2018 00:28:45 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/17.-letter-combinations-of-a-phone-number/</guid>
      <description>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example Input: &amp;quot;23&amp;quot; Output: [&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;]. Note Although the above answer is in lexicographical order, your answer could be in any order you want.</description>
    </item>
    
  </channel>
</rss>