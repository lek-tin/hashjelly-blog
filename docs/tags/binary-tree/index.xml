<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Binary Tree on Hashnopolis</title>
    <link>http://www.hashnopolis.com/tags/binary-tree/</link>
    <description>Recent content in Binary Tree on Hashnopolis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Hashnopolis</copyright>
    <lastBuildDate>Sun, 16 Sep 2018 15:05:12 -0700</lastBuildDate>
    
	<atom:link href="http://www.hashnopolis.com/tags/binary-tree/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Symmetric Tree</title>
      <link>http://www.hashnopolis.com/post/2018/09/symmetric-tree/</link>
      <pubDate>Sun, 16 Sep 2018 15:05:12 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/symmetric-tree/</guid>
      <description>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
For example, this binary tree [1,2,2,3,4,4,3] is symmetric:
 1 / \ 2 2 / \ / \ 3 4 4 3  But the following [1,2,2,null,3,null,3] is not:
 1 / \ 2 2 \ \ 3 3  Note: Bonus points if you could solve it both recursively and iteratively.
Solution:</description>
    </item>
    
    <item>
      <title>Same Tree</title>
      <link>http://www.hashnopolis.com/post/2018/09/same-tree/</link>
      <pubDate>Sun, 16 Sep 2018 15:03:53 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/same-tree/</guid>
      <description>Given two binary trees, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical and the nodes have the same value.
Example 1:
Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] Output: true  Example 2:
Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false  Example 3:
Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2] Output: false  Solution</description>
    </item>
    
    <item>
      <title>Swap Nodes in Pairs</title>
      <link>http://www.hashnopolis.com/post/2018/09/swap-nodes-in-pairs/</link>
      <pubDate>Sat, 15 Sep 2018 12:55:20 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/swap-nodes-in-pairs/</guid>
      <description>Given a linked list, swap every two adjacent nodes and return its head.
Example:
Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.  Note: - Your algorithm should use only constant extra space. - You may not modify the values in the list&amp;rsquo;s nodes, only nodes itself may be changed. Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def swapPairs(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; # https://www.</description>
    </item>
    
    <item>
      <title>Binary Tree Right Side View</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-right-side-view/</link>
      <pubDate>Thu, 13 Sep 2018 23:03:06 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-right-side-view/</guid>
      <description>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.
Example:
Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 &amp;lt;--- / \ 2 3 &amp;lt;--- \ \ 5 4 &amp;lt;---  Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.</description>
    </item>
    
    <item>
      <title>Binary Tree Preorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-preorder-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 23:02:11 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-preorder-traversal/</guid>
      <description>Given a binary tree, return the preorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,2,3]  Follow up: Recursive solution is trivial, could you do it iteratively?
Solution:
# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def preorderTraversal_1(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; if root is None: return [] return [root.</description>
    </item>
    
    <item>
      <title>Binary Tree Postorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-postorder-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 23:01:30 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-postorder-traversal/</guid>
      <description>Given a binary tree, return the postorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [3,2,1]  Follow up:
Recursive solution is trivial, could you do it iteratively?
Solution:
RecursiveðŸ‘‡
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def postorderTraversal(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; def traverse(node): if node == None: return [] return traverse(node.</description>
    </item>
    
    <item>
      <title>Binary Tree Paths</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-paths/</link>
      <pubDate>Thu, 13 Sep 2018 23:00:42 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-paths/</guid>
      <description>Given a binary tree, return all root-to-leaf paths.
Note: A leaf is a node with no children.
Example:
Input: 1 / \ 2 3 \ 5 Output: [&amp;quot;1-&amp;gt;2-&amp;gt;5&amp;quot;, &amp;quot;1-&amp;gt;3&amp;quot;]  Explanation: All root-to-leaf paths are: 1-&amp;gt;2-&amp;gt;5, 1-&amp;gt;3
Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def binaryTreePaths(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[str] &amp;quot;&amp;quot;&amp;quot; res = [] def traverse(root, path): if root == None: return path += str(root.</description>
    </item>
    
    <item>
      <title>Binary Tree Level Order Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 22:59:49 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal/</guid>
      <description>Given a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level).
For example:
Given binary tree `[3,9,20,null,null,15,7]`, 3 / \ 9 20 / \ 15 7  return its level order traversal as:
[ [3], [9,20], [15,7] ]  Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.</description>
    </item>
    
    <item>
      <title>Binary Tree Level Order Traversal II</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal-ii/</link>
      <pubDate>Thu, 13 Sep 2018 22:59:17 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal-ii/</guid>
      <description>Given a binary tree, return the bottom-up level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level from leaf to root).
For example: Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  return its bottom-up level order traversal as:
[ [15,7], [9,20], [3] ]  Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Binary Tree Inorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-inorder-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 22:57:42 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-inorder-traversal/</guid>
      <description>Given a binary tree, return the inorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,3,2]  Follow up: the Recursive solution is trivial, could you do it iteratively?
Solution
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def inorderTraversal(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot;Check root == None to reduce time on checking&amp;quot;&amp;quot;&amp;quot; if root == None: return [] stack = [] result = [] current = root while (current!</description>
    </item>
    
    <item>
      <title>Binary Search Tree Iterator</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-search-tree-iterator/</link>
      <pubDate>Sun, 09 Sep 2018 15:15:09 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-search-tree-iterator/</guid>
      <description>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.
Calling next() will return the next smallest number in the BST.
Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
Solution:
# Definition for a binary tree node # class TreeNode(object): # def __init__(self, x): # self.</description>
    </item>
    
  </channel>
</rss>