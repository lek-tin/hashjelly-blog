<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dynamic Programming on Hashnopolis</title>
    <link>http://www.hashnopolis.com/tags/dynamic-programming/</link>
    <description>Recent content in Dynamic Programming on Hashnopolis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Hashnopolis</copyright>
    <lastBuildDate>Fri, 26 Oct 2018 23:04:31 -0700</lastBuildDate>
    
	<atom:link href="http://www.hashnopolis.com/tags/dynamic-programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Minimum Path Sum</title>
      <link>http://www.hashnopolis.com/post/2018/10/minimum-path-sum/</link>
      <pubDate>Fri, 26 Oct 2018 23:04:31 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/minimum-path-sum/</guid>
      <description>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
Example:
Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7  Explanation: Because the path 1→3→1→1→1 minimizes the sum. Solution:
class Solution: def minPathSum(self, grid): &amp;quot;&amp;quot;&amp;quot; :type grid: List[List[int]] :rtype: int &amp;quot;&amp;quot;&amp;quot; for r in range(len(grid)): for c in range(len(grid[0])): if (r == 0 and c !</description>
    </item>
    
    <item>
      <title>Word Break</title>
      <link>http://www.hashnopolis.com/post/2018/10/word-break/</link>
      <pubDate>Wed, 10 Oct 2018 23:57:15 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/word-break/</guid>
      <description>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.
Note: - The same word in the dictionary may be reused multiple times in the segmentation. - You may assume the dictionary does not contain duplicate words. Example 1:
Input: s = &amp;quot;leetcode&amp;quot;, wordDict = [&amp;quot;leet&amp;quot;, &amp;quot;code&amp;quot;] Output: true Explanation: Return true because &amp;quot;leetcode&amp;quot; can be segmented as &amp;quot;leet code&amp;quot;.</description>
    </item>
    
    <item>
      <title>Unique Paths</title>
      <link>http://www.hashnopolis.com/post/2018/09/unique-paths/</link>
      <pubDate>Sat, 15 Sep 2018 12:54:17 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/unique-paths/</guid>
      <description>A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below).
How many possible unique paths are there?
Above is a 7 x 3 grid. How many possible unique paths are there?</description>
    </item>
    
  </channel>
</rss>