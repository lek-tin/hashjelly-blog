<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dfs on Hashnopolis</title>
    <link>http://www.hashnopolis.com/tags/dfs/</link>
    <description>Recent content in Dfs on Hashnopolis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Hashnopolis</copyright>
    <lastBuildDate>Thu, 02 Jan 2020 18:19:16 -0800</lastBuildDate>
    
	<atom:link href="http://www.hashnopolis.com/tags/dfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Package Dependencies</title>
      <link>http://www.hashnopolis.com/post/2020/01/package-dependencies/</link>
      <pubDate>Thu, 02 Jan 2020 18:19:16 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2020/01/package-dependencies/</guid>
      <description> Solution def package_dependencies(dependencies): result = [] visiting = set([]) visited = set([]) def dfs(node): if node in visited: return visiting.add(node) for dependency in node.dependencies: if dependency in visiting: raise Exception(&amp;quot;Have cycle in dependency graph.&amp;quot;) if dependency not in visited: dfs(dependency) for node in dependencies: dfs(node) visiting.remove(node) visited.add(node) result.add(add)  </description>
    </item>
    
    <item>
      <title>Word Ladder Ii</title>
      <link>http://www.hashnopolis.com/post/2019/11/word-ladder-ii/</link>
      <pubDate>Sat, 30 Nov 2019 16:03:43 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/11/word-ladder-ii/</guid>
      <description>Given two words (beginWord and endWord), and a dictionary&amp;rsquo;s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that: 1. Only one letter can be changed at a time 2. Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
Note:  Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters.</description>
    </item>
    
    <item>
      <title>Path Sum II</title>
      <link>http://www.hashnopolis.com/post/2019/11/path-sum-ii/</link>
      <pubDate>Sat, 30 Nov 2019 01:51:33 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/11/path-sum-ii/</guid>
      <description>Given a binary tree and a sum, find all root-to-leaf paths where each path&amp;rsquo;s sum equals the given sum.
Note: A leaf is a node with no children.
Example: Given the below binary tree and sum = 22,
 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1  Return:
[ [5,4,11,2], [5,8,4,5] ]  Solution # Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Path Sum</title>
      <link>http://www.hashnopolis.com/post/2019/10/path-sum/</link>
      <pubDate>Sat, 12 Oct 2019 17:43:14 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/10/path-sum/</guid>
      <description>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
Note: A leaf is a node with no children.
Example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.</description>
    </item>
    
    <item>
      <title>Convert Sorted List to Binary Search Tree</title>
      <link>http://www.hashnopolis.com/post/2019/10/convert-sorted-list-to-binary-search-tree/</link>
      <pubDate>Wed, 09 Oct 2019 23:51:44 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/10/convert-sorted-list-to-binary-search-tree/</guid>
      <description>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
Example: Given the sorted linked list: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5  Solution python</description>
    </item>
    
    <item>
      <title>Strobogrammatic Number II</title>
      <link>http://www.hashnopolis.com/post/2019/10/strobogrammatic-number-ii/</link>
      <pubDate>Wed, 02 Oct 2019 23:49:15 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/10/strobogrammatic-number-ii/</guid>
      <description>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).
Find all strobogrammatic numbers that are of length = n.
Example: Input: n = 2 Output: [&amp;quot;11&amp;quot;,&amp;quot;69&amp;quot;,&amp;quot;88&amp;quot;,&amp;quot;96&amp;quot;]  Solution # Time: O(n^2 * 5^(n/2)) # Space: `O(n)` class Solution: def findStrobogrammatic(self, n: int) -&amp;gt; List[str]: stroboPairs = { &amp;quot;0&amp;quot;: &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;6&amp;quot;: &amp;quot;9&amp;quot;, &amp;quot;8&amp;quot;: &amp;quot;8&amp;quot;, &amp;quot;9&amp;quot;: &amp;quot;6&amp;quot; } return self.build(stroboPairs, n, n) def build(self, stroboPairs, curr, n): if curr == 0: return [&amp;quot;&amp;quot;] if curr == 1: return list(&amp;quot;018&amp;quot;) prev = self.</description>
    </item>
    
    <item>
      <title>Clone Graph</title>
      <link>http://www.hashnopolis.com/post/2019/08/clone-graph/</link>
      <pubDate>Sun, 11 Aug 2019 01:12:12 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/08/clone-graph/</guid>
      <description>Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.
Example: Input: {&amp;quot;$id&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$id&amp;quot;:&amp;quot;2&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;1&amp;quot;},{&amp;quot;$id&amp;quot;:&amp;quot;3&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;2&amp;quot;},{&amp;quot;$id&amp;quot;:&amp;quot;4&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;3&amp;quot;},{&amp;quot;$ref&amp;quot;:&amp;quot;1&amp;quot;}],&amp;quot;val&amp;quot;:4}],&amp;quot;val&amp;quot;:3}],&amp;quot;val&amp;quot;:2},{&amp;quot;$ref&amp;quot;:&amp;quot;4&amp;quot;}],&amp;quot;val&amp;quot;:1} Explanation: Node 1&#39;s value is 1, and it has two neighbors: Node 2 and 4. Node 2&#39;s value is 2, and it has two neighbors: Node 1 and 3. Node 3&#39;s value is 3, and it has two neighbors: Node 2 and 4.</description>
    </item>
    
    <item>
      <title>Palindrome Partitioning</title>
      <link>http://www.hashnopolis.com/post/2019/08/palindrome-partitioning/</link>
      <pubDate>Wed, 07 Aug 2019 00:27:33 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/08/palindrome-partitioning/</guid>
      <description>Given a string s, partition s such that every substring of the partition is a palindrome.
Return all possible palindrome partitioning of s.
Example Input: &amp;quot;aab&amp;quot; Output: [ [&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;], [&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;] ]  Solution # Time: O(n*2^n) # Space: `O(n)`. At any time, only one call stack will be in progress # For example, in put &#39;ababaaeqwds&#39;, one possible call stack will look like &#39;aba&#39;-&amp;gt;&#39;b&#39;-&amp;gt;&#39;aa&#39;-&amp;gt;&#39;e&#39;-&amp;gt;&#39;q&#39;-&amp;gt;&#39;w&#39;-&amp;gt;&#39;d&#39;-&amp;gt;&#39;s&#39;: n space class Solution: def partition(self, s: str) -&amp;gt; List[List[str]]: if len(s) == 0 or s == None: return [] results = [] temp = [] self.</description>
    </item>
    
    <item>
      <title>Combination Sum Ii</title>
      <link>http://www.hashnopolis.com/post/2019/08/combination-sum-ii/</link>
      <pubDate>Tue, 06 Aug 2019 00:57:28 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/08/combination-sum-ii/</guid>
      <description>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.
Each number in candidates may only be used once in the combination.
Note All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.
Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]  ###Example 2:</description>
    </item>
    
    <item>
      <title>Generate Parentheses</title>
      <link>http://www.hashnopolis.com/post/2019/07/generate-parentheses/</link>
      <pubDate>Mon, 22 Jul 2019 23:08:05 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/07/generate-parentheses/</guid>
      <description>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
For example, given n = 3, a solution set is:
[ &amp;quot;((()))&amp;quot;, &amp;quot;(()())&amp;quot;, &amp;quot;(())()&amp;quot;, &amp;quot;()(())&amp;quot;, &amp;quot;()()()&amp;quot; ]  Solution class Solution: def generateParenthesis(self, n: int) -&amp;gt; List[str]: &amp;quot;&amp;quot;&amp;quot; :type n: int :rtype: List[str] &amp;quot;&amp;quot;&amp;quot; ans = [] self.dfs(ans, &#39;&#39;, 0, 0, n) return ans def dfs(self, ans, S, left, right, n): if len(S) == 2 * n: ans.</description>
    </item>
    
    <item>
      <title>Boundary of Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2019/03/boundary-of-binary-tree/</link>
      <pubDate>Sun, 10 Mar 2019 23:31:42 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/boundary-of-binary-tree/</guid>
      <description>Given a binary tree, return the values of its boundary in anti-clockwise direction starting from root. Boundary includes left boundary, leaves, and right boundary in order without duplicate nodes.
Left boundary is defined as the path from root to the left-most node. Right boundary is defined as the path from root to the right-most node. If the root doesn&amp;rsquo;t have left subtree or right subtree, then the root itself is left boundary or right boundary.</description>
    </item>
    
    <item>
      <title>Diameter of Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2019/03/diameter-of-binary-tree/</link>
      <pubDate>Sat, 09 Mar 2019 18:50:51 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/diameter-of-binary-tree/</guid>
      <description>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.
Example: Given a binary tree 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</description>
    </item>
    
    <item>
      <title>Number of Connected Components in an Undirected Graph</title>
      <link>http://www.hashnopolis.com/post/2019/03/number-of-connected-components-in-an-undirected-graph/</link>
      <pubDate>Thu, 07 Mar 2019 11:40:26 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/number-of-connected-components-in-an-undirected-graph/</guid>
      <description>Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.
Example 1: Input: n = 5 and edges = [[0, 1], [1, 2], [3, 4]] 0 3 | | 1 --- 2 4 Output: 2  Example 2: Input: n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]] 0 4 | | 1 --- 2 --- 3 Output: 1  Note: You can assume that no duplicate edges will appear in edges.</description>
    </item>
    
    <item>
      <title>Course Schedule</title>
      <link>http://www.hashnopolis.com/post/2018/12/course-schedule/</link>
      <pubDate>Sun, 09 Dec 2018 23:29:18 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/12/course-schedule/</guid>
      <description>There are a total of n courses you have to take, labeled from 0 to n-1.
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?
Example 1 Input: 2, [[1,0]] Output: true Explanation: There are a total of 2 courses to take.</description>
    </item>
    
    <item>
      <title>Word Break II</title>
      <link>http://www.hashnopolis.com/post/2018/11/word-break-ii/</link>
      <pubDate>Thu, 29 Nov 2018 00:00:35 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/word-break-ii/</guid>
      <description>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.
Note  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.
Example 1 Input: s = &amp;quot;catsanddog&amp;quot; wordDict = [&amp;quot;cat&amp;quot;, &amp;quot;cats&amp;quot;, &amp;quot;and&amp;quot;, &amp;quot;sand&amp;quot;, &amp;quot;dog&amp;quot;] Output: [ &amp;quot;cats and dog&amp;quot;, &amp;quot;cat sand dog&amp;quot; ]  Example 2 Input: s = &amp;quot;pineapplepenapple&amp;quot; wordDict = [&amp;quot;apple&amp;quot;, &amp;quot;pen&amp;quot;, &amp;quot;applepen&amp;quot;, &amp;quot;pine&amp;quot;, &amp;quot;pineapple&amp;quot;] Output: [ &amp;quot;pine apple pen apple&amp;quot;, &amp;quot;pineapple pen apple&amp;quot;, &amp;quot;pine applepen apple&amp;quot; ] Explanation: Note that you are allowed to reuse a dictionary word.</description>
    </item>
    
    <item>
      <title>Remove Invalid Parentheses</title>
      <link>http://www.hashnopolis.com/post/2018/11/remove-invalid-parentheses/</link>
      <pubDate>Tue, 13 Nov 2018 16:20:10 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/remove-invalid-parentheses/</guid>
      <description>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.
Note The input string may contain letters other than the parentheses ( and ). *### Example 1
Input: &amp;quot;()())()&amp;quot; Output: [&amp;quot;()()()&amp;quot;, &amp;quot;(())()&amp;quot;]  *### Example 2
Input: &amp;quot;(a)())()&amp;quot; Output: [&amp;quot;(a)()()&amp;quot;, &amp;quot;(a())()&amp;quot;]  *### Example 3
Input: &amp;quot;)(&amp;quot; Output: [&amp;quot;&amp;quot;]  *### Solution
# Credit: # Credit: https://leetcode.com/problems/remove-invalid-parentheses/discuss/186597/Very-easy-to-understand-Python-DFS class Solution(object): def removeInvalidParentheses(self, s): &amp;quot;&amp;quot;&amp;quot; :type s: str :rtype: List[str] &amp;quot;&amp;quot;&amp;quot; res = [] self.</description>
    </item>
    
    <item>
      <title>Add and Search Word Data Structure Design</title>
      <link>http://www.hashnopolis.com/post/2018/11/add-and-search-word-data-structure-design/</link>
      <pubDate>Thu, 08 Nov 2018 22:37:27 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/add-and-search-word-data-structure-design/</guid>
      <description>Design a data structure that supports the following two operations:
void addWord(word) bool search(word)  search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.
Example addWord(&amp;quot;bad&amp;quot;) addWord(&amp;quot;dad&amp;quot;) addWord(&amp;quot;mad&amp;quot;) search(&amp;quot;pad&amp;quot;) -&amp;gt; false search(&amp;quot;bad&amp;quot;) -&amp;gt; true search(&amp;quot;.ad&amp;quot;) -&amp;gt; true search(&amp;quot;b..&amp;quot;) -&amp;gt; true  Note You may assume that all words are consist of lowercase letters a-z.</description>
    </item>
    
    <item>
      <title>Lowest Common Ancestor of a Binary Search Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-search-tree/</link>
      <pubDate>Thu, 01 Nov 2018 13:23:27 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-search-tree/</guid>
      <description>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5]</description>
    </item>
    
    <item>
      <title>Lowest Common Ancestor of a Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Thu, 01 Nov 2018 13:18:53 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the : “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]
 _______3______ / \ ___5__ ___1__  / \ / 6 _2 0 8 / 7 4</description>
    </item>
    
    <item>
      <title>Word Search</title>
      <link>http://www.hashnopolis.com/post/2018/10/word-search/</link>
      <pubDate>Mon, 15 Oct 2018 23:48:28 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/word-search/</guid>
      <description>Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where &amp;ldquo;adjacent&amp;rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
Example board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] Given word = &amp;quot;ABCCED&amp;quot;, return true. Given word = &amp;quot;SEE&amp;quot;, return true. Given word = &amp;quot;ABCB&amp;quot;, return false.</description>
    </item>
    
    <item>
      <title>Number of Islands</title>
      <link>http://www.hashnopolis.com/post/2018/10/number-of-islands/</link>
      <pubDate>Tue, 09 Oct 2018 23:52:32 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/number-of-islands/</guid>
      <description>Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
Example 1 Input: 11110 11010 11000 00000 Output: 1  Example 2 Input: 11000 11000 00100 00011 Output: 3  DFS
Solution class Solution: def numIslands(self, grid): &amp;quot;&amp;quot;&amp;quot; :type grid: List[List[str]] :rtype: int &amp;quot;&amp;quot;&amp;quot; # Edge cases if not grid or len(grid) == 0 or len(grid[0]) == 0: return 0 rows = len(grid) cols = len(grid[0]) count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == &amp;quot;1&amp;quot;: count += 1 self.</description>
    </item>
    
    <item>
      <title>Binary Tree Maximum Path Sum</title>
      <link>http://www.hashnopolis.com/post/2018/10/binary-tree-maximum-path-sum/</link>
      <pubDate>Tue, 09 Oct 2018 23:50:03 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/binary-tree-maximum-path-sum/</guid>
      <description>Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
Example 1 Input: [1,2,3] 1 / \ 2 3 Output: 6  Example 2 Input: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7 Output: 42  Solution # Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Subsets Ii</title>
      <link>http://www.hashnopolis.com/post/2018/10/subsets-ii/</link>
      <pubDate>Mon, 08 Oct 2018 13:04:14 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/subsets-ii/</guid>
      <description>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).
Note The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]  Solution # Time: o(2^n) # Space: `O(n)` class Solution: def subsetsWithDup(self, nums: List[int]) -&amp;gt; List[List[int]]: results = [] subset = [] # Edge case 1 if nums == None: return results # Edge case 2 if len(nums) == 0: results.</description>
    </item>
    
    <item>
      <title>Subsets</title>
      <link>http://www.hashnopolis.com/post/2018/09/subsets/</link>
      <pubDate>Sat, 15 Sep 2018 12:48:42 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/subsets/</guid>
      <description>Given a set of distinct integers, nums, return all possible subsets (the power set).
Note The solution set must not contain duplicate subsets. Example Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]  Solution # Time: o(2^n) # Space: `O(n)` class Solution: def subsets(self, nums: List[int]) -&amp;gt; List[List[int]]: results = [] subset = [] # Edge case 1 if nums == None: return results # Edge case 2 if len(nums) == 0: results.</description>
    </item>
    
    <item>
      <title>17. Letter Combinations of a Phone Number</title>
      <link>http://www.hashnopolis.com/post/2018/09/17.-letter-combinations-of-a-phone-number/</link>
      <pubDate>Mon, 03 Sep 2018 00:28:45 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/17.-letter-combinations-of-a-phone-number/</guid>
      <description>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example Input: &amp;quot;23&amp;quot; Output: [&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;].  Note Although the above answer is in lexicographical order, your answer could be in any order you want.</description>
    </item>
    
  </channel>
</rss>