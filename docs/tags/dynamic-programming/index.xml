<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dynamic Programming on Hashnopolis</title>
    <link>http://www.hashnopolis.com/tags/dynamic-programming/</link>
    <description>Recent content in Dynamic Programming on Hashnopolis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Hashnopolis</copyright>
    <lastBuildDate>Sat, 07 Sep 2019 23:58:51 -0800</lastBuildDate>
    
	<atom:link href="http://www.hashnopolis.com/tags/dynamic-programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Coin Change</title>
      <link>http://www.hashnopolis.com/post/2019/09/coin-change/</link>
      <pubDate>Sat, 07 Sep 2019 23:58:51 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/09/coin-change/</guid>
      <description>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.
Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1  Example 2: Input: coins = [2], amount = 3 Output: -1  Note: You may assume that you have an infinite number of each kind of coin.</description>
    </item>
    
    <item>
      <title>Maximum Product Subarray</title>
      <link>http://www.hashnopolis.com/post/2019/09/maximum-product-subarray/</link>
      <pubDate>Wed, 04 Sep 2019 23:44:12 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/09/maximum-product-subarray/</guid>
      <description> Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.
Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6.  Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.  Solution # time: o(n) class Solution: def maxProduct(self, nums: List[int]) -&amp;gt; int: n = len(nums) if n == 0: return 0 res = currMax = currMin = nums[0] for i in range(1, n): newCurrMax = max(max(currMax * nums[i], currMin * nums[i]), nums[i]) newCurrMin = min(min(currMax * nums[i], currMin * nums[i]), nums[i]) currMax, currMin = newCurrMax, newCurrMin res = max(currMax, res) return res  </description>
    </item>
    
    <item>
      <title>Triangle</title>
      <link>http://www.hashnopolis.com/post/2019/09/triangle/</link>
      <pubDate>Wed, 04 Sep 2019 23:06:05 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/09/triangle/</guid>
      <description>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.
For example, given the following triangle
[ [2], [3,4], [6,5,7], [4,1,8,3] ] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).  Note:  Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</description>
    </item>
    
    <item>
      <title>Minimum Path Sum</title>
      <link>http://www.hashnopolis.com/post/2019/09/minimum-path-sum/</link>
      <pubDate>Mon, 02 Sep 2019 23:04:31 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/09/minimum-path-sum/</guid>
      <description>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
Note You can only move either down or right at any point in time. Example Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7  Explanation Because the path 1→3→1→1→1 minimizes the sum. Solution class Solution: def minPathSum(self, grid): &amp;quot;&amp;quot;&amp;quot; :type grid: List[List[int]] :rtype: int &amp;quot;&amp;quot;&amp;quot; for r in range(len(grid)): for c in range(len(grid[0])): if (r == 0 and c !</description>
    </item>
    
    <item>
      <title>Largest Divisible Subset</title>
      <link>http://www.hashnopolis.com/post/2019/08/largest-divisible-subset/</link>
      <pubDate>Thu, 29 Aug 2019 02:15:01 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/08/largest-divisible-subset/</guid>
      <description>Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies:
Si % Sj = 0 or Sj % Si = 0.
If there are multiple solutions, return any subset is fine.
Example 1: Input: [1,2,3] Output: [1,2] (of course, [1,3] will also be ok)  Example 2: Input: [1,2,4,8] Output: [1,2,4,8]  Solution class Solution: def largestDivisibleSubset(self, nums: List[int]) -&amp;gt; List[int]: if not nums or len(nums) == 0: return [] nums.</description>
    </item>
    
    <item>
      <title>Coin Change 2</title>
      <link>http://www.hashnopolis.com/post/2019/04/coin-change-2/</link>
      <pubDate>Sat, 06 Apr 2019 22:45:41 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/04/coin-change-2/</guid>
      <description>You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.
Example 1: Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1  Example 2: Input: amount = 3, coins = [2] Output: 0 Explanation: the amount of 3 cannot be made up just with coins of 2.</description>
    </item>
    
    <item>
      <title>Maximum Path Sum</title>
      <link>http://www.hashnopolis.com/post/2019/03/maximum-path-sum/</link>
      <pubDate>Sat, 16 Mar 2019 01:17:11 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/maximum-path-sum/</guid>
      <description>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
Example: Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum.  Solution class Solution { public int minPathSum(int[][] grid) { if (grid == null || grid.</description>
    </item>
    
    <item>
      <title>Unique Paths II</title>
      <link>http://www.hashnopolis.com/post/2019/03/unique-paths-ii/</link>
      <pubDate>Sat, 02 Mar 2019 12:24:17 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/unique-paths-ii/</guid>
      <description>A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below).
Now consider if some obstacles are added to the grids. How many unique paths would there be?</description>
    </item>
    
    <item>
      <title>Maximal Rectangle</title>
      <link>http://www.hashnopolis.com/post/2019/02/maximal-rectangle/</link>
      <pubDate>Mon, 25 Feb 2019 00:41:33 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/maximal-rectangle/</guid>
      <description>Given a 2D binary matrix filled with 0&amp;rsquo;s and 1&amp;rsquo;s, find the largest rectangle containing only 1&amp;rsquo;s and return its area.
Example: Input: [ [&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;] ] Output: 6  Hint Height:
1 0 1 0 0 2 0 2 1 1 3 1 3 2 2 4 0 0 3 0  Left:
0 0 2 0 0 0 0 2 2 2 0 0 2 2 2 0 0 0 3 0  Right:</description>
    </item>
    
    <item>
      <title>House Robber II</title>
      <link>http://www.hashnopolis.com/post/2019/02/house-robber-ii/</link>
      <pubDate>Thu, 21 Feb 2019 19:39:05 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/house-robber-ii/</guid>
      <description>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title>Maximum Subarray</title>
      <link>http://www.hashnopolis.com/post/2019/02/maximum-subarray/</link>
      <pubDate>Wed, 20 Feb 2019 22:30:14 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/maximum-subarray/</guid>
      <description>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.  Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
Solution: Dynamic Programming
class Solution { public int maxSubArray(int[] nums) { if (nums.</description>
    </item>
    
    <item>
      <title>Longest Common Subsequence</title>
      <link>http://www.hashnopolis.com/post/2019/02/longest-common-subsequence/</link>
      <pubDate>Fri, 15 Feb 2019 17:28:18 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/longest-common-subsequence/</guid>
      <description>The longest common subsequence (LCS) problem is the problem of finding the longest subsequence common to all sequences in a set of sequences (often just two sequences). It differs from the longest common substring problem: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences.
Optimal Substructure: Let the input sequences be X[0..m-1] and Y[0..n-1] of lengths m and n respectively. And let L(X[0..m-1], Y[0..n-1]) be the length of LCS of the two sequences X and Y.</description>
    </item>
    
    <item>
      <title>Longest Palindromic Substring</title>
      <link>http://www.hashnopolis.com/post/2019/01/longest-palindromic-substring/</link>
      <pubDate>Tue, 22 Jan 2019 22:29:56 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/longest-palindromic-substring/</guid>
      <description>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.
Example 1 Input: &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Note: &amp;quot;aba&amp;quot; is also a valid answer.  Example 2 Input: &amp;quot;cbbd&amp;quot; Output: &amp;quot;bb&amp;quot;  Solution Dynamic Programming
# https://leetcode.com/problems/longest-palindromic-substring/discuss/157861/Python3-DP-Solution-with-Lots-of-Comments # time: O(n^2) # space: O(n^2) class Solution(object): def longestPalindrome(self, s): &amp;quot;&amp;quot;&amp;quot; :type s: str :rtype: str &amp;quot;&amp;quot;&amp;quot; str_len = len(s) if str_len == 0: return &amp;quot;&amp;quot; # Initialize DP table (dimensions: str_len x str_len) memo = [[False for i in range(str_len)] for j in range(str_len)] start = 0 # Starting index of the longest palindrome max_len = 1 # Length of the longest palindrome # Fill DP table for single char palindromes for i in range(str_len): memo[i][i] = True # Fill DP table for 2 char long palindromes for i in range(str_len - 1): j = i + 1 if s[i] == s[j]: memo[i][j] = True start = i max_len = 2 # Fill DP table for palindromes of every other length # starting from 3 length = 3 for length in range(3, str_len + 1): for i in range(str_len - length + 1): j = i + (length - 1) if s[i] == s[j] and memo[i+1][j-1]: memo[i][j] = True start = i max_len = length solution = s[start: start + max_len] return solution  # time: O(n^2) # space: O(1) class Solution(object): def __init__(self): self.</description>
    </item>
    
    <item>
      <title>Edit Distance</title>
      <link>http://www.hashnopolis.com/post/2019/01/edit-distance/</link>
      <pubDate>Thu, 17 Jan 2019 23:56:53 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/edit-distance/</guid>
      <description>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.
You have the following 3 operations permitted on a word: 1. Insert a character 2. Delete a character 3. Replace a character
Example 1: Input: word1 = &amp;quot;horse&amp;quot;, word2 = &amp;quot;ros&amp;quot; Output: 3 Explanation: horse -&amp;gt; rorse (replace &#39;h&#39; with &#39;r&#39;) rorse -&amp;gt; rose (remove &#39;r&#39;) rose -&amp;gt; ros (remove &#39;e&#39;)  Example 2: Input: word1 = &amp;quot;intention&amp;quot;, word2 = &amp;quot;execution&amp;quot; Output: 5 Explanation: intention -&amp;gt; inention (remove &#39;t&#39;) inention -&amp;gt; enention (replace &#39;i&#39; with &#39;e&#39;) enention -&amp;gt; exention (replace &#39;n&#39; with &#39;x&#39;) exention -&amp;gt; exection (replace &#39;n&#39; with &#39;c&#39;) exection -&amp;gt; execution (insert &#39;u&#39;)  Solution: class Solution { public int minDistance(String word1, String word2) { if (word1 == null || word2 == null) return -1; if (word1.</description>
    </item>
    
    <item>
      <title>Maximal Square</title>
      <link>http://www.hashnopolis.com/post/2018/11/maximal-square/</link>
      <pubDate>Thu, 01 Nov 2018 23:18:11 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/maximal-square/</guid>
      <description>Given a 2D binary matrix filled with 0&amp;rsquo;s and 1&amp;rsquo;s, find the largest square containing only 1&amp;rsquo;s and return its area.
Example Input:
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
Output: 4
Solution class Solution: def maximalSquare(self, matrix): &amp;quot;&amp;quot;&amp;quot; :type matrix: List[List[str]] :rtype: int &amp;quot;&amp;quot;&amp;quot; area = 0 if not matrix: return area # Edge case: single col matrix for i in range(len(matrix)): if matrix[i][0] == &amp;quot;1&amp;quot;: matrix[i][0] = 1 area = 1 # Edge case: single row matrix for i in range(len(matrix[0])): if matrix[0][i] == &amp;quot;1&amp;quot;: matrix[0][i] = 1 area = 1 for i in range(1, len(matrix)): for j in range(1, len(matrix[0])): if matrix[i][j] == &amp;quot;0&amp;quot;: matrix[i][j] = 0 continue localMin = min( int(matrix[i-1][j]), int(matrix[i-1][j-1]), int(matrix[i][j-1]) ) print(int(matrix[i-1][j]), int(matrix[i-1][j-1]), int(matrix[i][j-1])) matrix[i][j] = localMin + 1 if matrix[i][j] &amp;gt; area: area = matrix[i][j] return area**2  class Solution { public int maximalSquare(char[][] matrix) { if (matrix.</description>
    </item>
    
    <item>
      <title>House Robber</title>
      <link>http://www.hashnopolis.com/post/2018/10/house-robber/</link>
      <pubDate>Thu, 25 Oct 2018 23:45:32 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/house-robber/</guid>
      <description>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title>Word Break</title>
      <link>http://www.hashnopolis.com/post/2018/10/word-break/</link>
      <pubDate>Wed, 10 Oct 2018 23:57:15 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/word-break/</guid>
      <description>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.
Note  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.
Example 1 Input: s = &amp;quot;leetcode&amp;quot;, wordDict = [&amp;quot;leet&amp;quot;, &amp;quot;code&amp;quot;] Output: true Explanation: Return true because &amp;quot;leetcode&amp;quot; can be segmented as &amp;quot;leet code&amp;quot;.</description>
    </item>
    
    <item>
      <title>Decode Ways</title>
      <link>http://www.hashnopolis.com/post/2018/10/decode-ways/</link>
      <pubDate>Wed, 03 Oct 2018 23:49:00 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/decode-ways/</guid>
      <description>A message containing letters from A-Z is being encoded to numbers using the following mapping:
&amp;lsquo;A&amp;rsquo; -&amp;gt; 1 &amp;lsquo;B&amp;rsquo; -&amp;gt; 2 &amp;hellip; &amp;lsquo;Z&amp;rsquo; -&amp;gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it.
Example 1 Input: &amp;quot;12&amp;quot; Output: 2 Explanation: It could be decoded as &amp;quot;AB&amp;quot; (1 2) or &amp;quot;L&amp;quot; (12).  Example 2 Input: &amp;quot;226&amp;quot; Output: 3 Explanation: It could be decoded as &amp;quot;BZ&amp;quot; (2 26), &amp;quot;VF&amp;quot; (22 6), or &amp;quot;BBF&amp;quot; (2 2 6).</description>
    </item>
    
    <item>
      <title>Unique Binary Search Trees</title>
      <link>http://www.hashnopolis.com/post/2018/09/unique-binary-search-trees/</link>
      <pubDate>Sun, 16 Sep 2018 15:06:01 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/unique-binary-search-trees/</guid>
      <description>Given n, how many structurally unique BST&amp;rsquo;s (binary search trees) that store values 1 &amp;hellip; n?
Example Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST&#39;s: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3  Exaplanation n = 3 root: 1 left: 0 right: 2 f(0)*f(2); root: 2 left: 1 right: 1 f(1)*f(1); root: 3 left: 2 right: 0 f(2)*f(0);  Solution class Solution: def numTrees(self, n): &amp;quot;&amp;quot;&amp;quot; :type n: int :rtype: int &amp;quot;&amp;quot;&amp;quot; res = [1] for i in range(1, n+1): for j in range(i): res.</description>
    </item>
    
    <item>
      <title>Unique Paths</title>
      <link>http://www.hashnopolis.com/post/2018/09/unique-paths/</link>
      <pubDate>Sat, 15 Sep 2018 12:54:17 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/unique-paths/</guid>
      <description>A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below).
How many possible unique paths are there?
Above is a 7 x 3 grid. How many possible unique paths are there?</description>
    </item>
    
  </channel>
</rss>