<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Binary Search on Hashnopolis</title>
    <link>http://www.hashnopolis.com/tags/binary-search/</link>
    <description>Recent content in Binary Search on Hashnopolis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Hashnopolis</copyright>
    <lastBuildDate>Mon, 23 Sep 2019 01:36:19 -0700</lastBuildDate>
    
	<atom:link href="http://www.hashnopolis.com/tags/binary-search/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Find in Mountain Array</title>
      <link>http://www.hashnopolis.com/post/2019/09/find-in-mountain-array/</link>
      <pubDate>Mon, 23 Sep 2019 01:36:19 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/09/find-in-mountain-array/</guid>
      <description>(This problem is an interactive problem.)
You may recall that an array A is a mountain array if and only if: 1. A.length &amp;gt;= 3 2. There exists some i with 0 &amp;lt; i &amp;lt; A.length - 1 such that: * A[0] &amp;lt; A[1] &amp;lt; ... A[i-1] &amp;lt; A[i] * A[i] &amp;gt; A[i+1] &amp;gt; ... &amp;gt; A[A.length - 1] Given a mountain array mountainArr, return the minimum index such that mountainArr.</description>
    </item>
    
    <item>
      <title>Peak Index in a Mountain Array</title>
      <link>http://www.hashnopolis.com/post/2019/09/peak-index-in-a-mountain-array/</link>
      <pubDate>Mon, 23 Sep 2019 01:02:35 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/09/peak-index-in-a-mountain-array/</guid>
      <description>Let&amp;rsquo;s call an array A a mountain if the following properties hold: 1. A.length &amp;gt;= 3 2. There exists some 0 &amp;lt; i &amp;lt; A.length - 1 such that A[0] &amp;lt; A[1] &amp;lt; ... A[i-1] &amp;lt; A[i] &amp;gt; A[i+1] &amp;gt; ... &amp;gt; A[A.length - 1]
Given an array that is definitely a mountain, return any i such that A[0] &amp;lt; A[1] &amp;lt; ... A[i-1] &amp;lt; A[i] &amp;gt; A[i+1] &amp;gt; .</description>
    </item>
    
    <item>
      <title>Valid Perfect Square</title>
      <link>http://www.hashnopolis.com/post/2019/09/valid-perfect-square/</link>
      <pubDate>Thu, 19 Sep 2019 23:47:10 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/09/valid-perfect-square/</guid>
      <description>Given a positive integer num, write a function which returns True if num is a perfect square else False.
Note: Do not use any built-in library function such as sqrt.
Example 1: Input: 16 Output: true  Example 2: Input: 14 Output: false  Solution Binary search version 1
class Solution: def isPerfectSquare(self, num: int) -&amp;gt; bool: if num == 1: return True left, right = 0, num while left &amp;lt;= right: mid = left + (right-left)//2 t = mid*mid if t == num: return True if t &amp;lt; num: left = mid + 1 else: right = mid - 1 return False  Binary search version 2</description>
    </item>
    
    <item>
      <title>Guess Number Higher or Lower</title>
      <link>http://www.hashnopolis.com/post/2019/09/guess-number-higher-or-lower/</link>
      <pubDate>Thu, 19 Sep 2019 23:19:54 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/09/guess-number-higher-or-lower/</guid>
      <description>We are playing the Guess Game. The game is as follows:
I pick a number from 1 to n. You have to guess which number I picked.
Every time you guess wrong, I&amp;rsquo;ll tell you whether the number is higher or lower.
You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):
-1 : My number is lower 1 : My number is higher 0 : Congrats!</description>
    </item>
    
    <item>
      <title>Russian Doll Envelopes</title>
      <link>http://www.hashnopolis.com/post/2019/09/russian-doll-envelopes/</link>
      <pubDate>Tue, 10 Sep 2019 00:37:14 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/09/russian-doll-envelopes/</guid>
      <description>You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.
What is the maximum number of envelopes can you Russian doll? (put one inside other)
Note: Rotation is not allowed.
Example: Input: [[5,4],[6,4],[6,7],[2,3]] Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] =&amp;gt; [5,4] =&amp;gt; [6,7]).</description>
    </item>
    
    <item>
      <title>Search a 2d Matrix Ii</title>
      <link>http://www.hashnopolis.com/post/2019/04/search-a-2d-matrix-ii/</link>
      <pubDate>Tue, 02 Apr 2019 23:59:01 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/04/search-a-2d-matrix-ii/</guid>
      <description>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
- Integers in each row are sorted in ascending from left to right. - Integers in each column are sorted in ascending from top to bottom.
Example: Consider the following matrix: [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ]  Given target = 5, return true.</description>
    </item>
    
    <item>
      <title>Find K Closest Elements</title>
      <link>http://www.hashnopolis.com/post/2019/03/find-k-closest-elements/</link>
      <pubDate>Thu, 14 Mar 2019 16:00:58 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/find-k-closest-elements/</guid>
      <description>Given a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.
Example 1: Input: [1,2,3,4,5], k=4, x=3 Output: [1,2,3,4]  Example 2: Input: [1,2,3,4,5], k=4, x=-1 Output: [1,2,3,4]  Note:  The value k is positive and will always be smaller than the length of the sorted array.</description>
    </item>
    
    <item>
      <title>Find a Local Minima in an Array</title>
      <link>http://www.hashnopolis.com/post/2019/01/find-a-local-minima-in-an-array/</link>
      <pubDate>Mon, 14 Jan 2019 11:32:08 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/find-a-local-minima-in-an-array/</guid>
      <description>Given an array arr[0 .. n-1] of distinct integers, the task is to find a local minima in it. We say that an element arr[x] is a local minimum if it is less than or equal to both its neighbors.
For corner elements, we need to consider only one neighbor for comparison. There can be more than one local minima in an array, we need to find any one of them.</description>
    </item>
    
    <item>
      <title>Sqrtx</title>
      <link>http://www.hashnopolis.com/post/2018/11/sqrtx/</link>
      <pubDate>Thu, 08 Nov 2018 21:59:03 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/sqrtx/</guid>
      <description>Implement int sqrt(int x).
Compute and return the square root of x, where x is guaranteed to be a non-negative integer.
Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.
Example 1 Input: 4 Output: 2  Example 2 Input: 8 Output: 2  Explanation: The square root of 8 is 2.82842&amp;hellip;, and since the decimal part is truncated, 2 is returned.</description>
    </item>
    
    <item>
      <title>Search a 2D Matrix</title>
      <link>http://www.hashnopolis.com/post/2018/10/search-a-2d-matrix/</link>
      <pubDate>Tue, 30 Oct 2018 23:56:03 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/search-a-2d-matrix/</guid>
      <description>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: - Integers in each row are sorted from left to right. - The first integer of each row is greater than the last integer of the previous row.
Example 1 Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true  Example 2 Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 Output: false  Solution # Treat the 2-d matrix as a 1-d list of length rows * cols.</description>
    </item>
    
    <item>
      <title>Find First and Last Position of Element in Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/10/find-first-and-last-position-of-element-in-sorted-array/</link>
      <pubDate>Fri, 26 Oct 2018 23:10:23 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/find-first-and-last-position-of-element-in-sorted-array/</guid>
      <description>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].
Example 1 Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]  Example 2 Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]  Solution Time: O(logN)</description>
    </item>
    
    <item>
      <title>Search in Rotated Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/10/search-in-rotated-sorted-array/</link>
      <pubDate>Fri, 26 Oct 2018 23:08:49 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/search-in-rotated-sorted-array/</guid>
      <description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).
Example 1 Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4  Example 2 Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1  Solution class Solution: def search(self, nums: List[int], target: int) -&amp;gt; int: if nums == None or len(nums) == 0: return -1 start, end = 0, len(nums) - 1 while (start + 1) &amp;lt; end: mid = start + (end - start) // 2 if nums[mid] == target: return mid # &amp;lt; because there are no duplicate numbers.</description>
    </item>
    
    <item>
      <title>First Bad Version</title>
      <link>http://www.hashnopolis.com/post/2018/10/first-bad-version/</link>
      <pubDate>Fri, 26 Oct 2018 23:07:46 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/first-bad-version/</guid>
      <description>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</description>
    </item>
    
    <item>
      <title>Find Minimum in Rotated Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/09/find-minimum-in-rotated-sorted-array/</link>
      <pubDate>Fri, 14 Sep 2018 11:50:46 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/find-minimum-in-rotated-sorted-array/</guid>
      <description> Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
Find the minimum element.
You may assume no duplicate exists in the array.
Example 1 Input: [3,4,5,1,2] Output: 1  Example 2 Input: [4,5,6,7,0,1,2] Output: 0  Solution class Solution: def findMin(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: int &amp;quot;&amp;quot;&amp;quot; if len(nums) == 1: return nums[0] if len(nums) == 2: return min(nums[0], nums[1]) if nums[0] &amp;lt; nums[len(nums)-1]: return nums[0] if nums[len(nums)-2] &amp;gt; nums[len(nums)-1]: return nums[len(nums)-1] for i in range(1, len(nums)-1): if nums[i] &amp;lt; nums[i-1] and nums[i] &amp;lt; nums[i+1]: return nums[i] def bsFindMin(self, nums): l, r = 0, len(nums) - 1 while l &amp;lt; r: m = (l + r) // 2 if nums[m] &amp;gt; nums[m - 1] and nums[m] &amp;gt; nums[m + 1]: return nums[m + 1] if nums[m] &amp;lt; nums[m - 1] and nums[m] &amp;lt; nums[m + 1]: return nums[m] if nums[m] &amp;gt;= nums[r]: l = m else: r = m return nums[0]  </description>
    </item>
    
    <item>
      <title>4. Median of Two Sorted Arrays</title>
      <link>http://www.hashnopolis.com/post/2018/08/4.-median-of-two-sorted-arrays/</link>
      <pubDate>Tue, 21 Aug 2018 20:54:32 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/4.-median-of-two-sorted-arrays/</guid>
      <description>There are two sorted arrays nums1 and nums2 of size m and n respectively.
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
You may assume nums1 and nums2 cannot be both empty.
Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0  Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.</description>
    </item>
    
    <item>
      <title>Search in Rotated Sorted Array II</title>
      <link>http://www.hashnopolis.com/post/2018/08/search-in-rotated-sorted-array-ii/</link>
      <pubDate>Wed, 15 Aug 2018 12:50:21 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/search-in-rotated-sorted-array-ii/</guid>
      <description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).
You are given a target value to search. If found in the array return true, otherwise return false.
Example 1:
Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true  Example 2:
Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false  Follow-up  This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.</description>
    </item>
    
  </channel>
</rss>