<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Hashnopolis</title>
    <link>http://www.hashnopolis.com/tags/java/</link>
    <description>Recent content in Java on Hashnopolis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Hashnopolis</copyright>
    <lastBuildDate>Fri, 15 Feb 2019 17:28:18 -0800</lastBuildDate>
    
	<atom:link href="http://www.hashnopolis.com/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Longest Common Subsequence</title>
      <link>http://www.hashnopolis.com/post/2019/02/longest-common-subsequence/</link>
      <pubDate>Fri, 15 Feb 2019 17:28:18 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/longest-common-subsequence/</guid>
      <description>The longest common subsequence (LCS) problem is the problem of finding the longest subsequence common to all sequences in a set of sequences (often just two sequences). It differs from the longest common substring problem: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences.
Optimal Substructure: Let the input sequences be X[0..m-1] and Y[0..n-1] of lengths m and n respectively. And let L(X[0..m-1], Y[0..n-1]) be the length of LCS of the two sequences X and Y.</description>
    </item>
    
    <item>
      <title>Minimum Depth of Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2019/02/minimum-depth-of-binary-tree/</link>
      <pubDate>Tue, 12 Feb 2019 16:58:46 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/minimum-depth-of-binary-tree/</guid>
      <description>Given a binary tree, find its minimum depth.
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
Note: A leaf is a node with no children.
Example: Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7 return its minimum depth = 2.  Solution: /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Trapping Rain Water</title>
      <link>http://www.hashnopolis.com/post/2019/01/trapping-rain-water/</link>
      <pubDate>Sat, 26 Jan 2019 23:39:49 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/trapping-rain-water/</guid>
      <description>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!
Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6  Solution: class Solution { public int trap(int[] height) { int n = height.</description>
    </item>
    
    <item>
      <title>Container With Most Water</title>
      <link>http://www.hashnopolis.com/post/2019/01/container-with-most-water/</link>
      <pubDate>Sat, 26 Jan 2019 23:38:02 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/container-with-most-water/</guid>
      <description>Given n non-negative integers a1, a2, &amp;hellip;, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7].</description>
    </item>
    
    <item>
      <title>Alien Dictionary</title>
      <link>http://www.hashnopolis.com/post/2018/12/alien-dictionary/</link>
      <pubDate>Sat, 08 Dec 2018 23:57:13 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/12/alien-dictionary/</guid>
      <description>There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.
Example 1:
Input: [ &amp;quot;wrt&amp;quot;, &amp;quot;wrf&amp;quot;, &amp;quot;er&amp;quot;, &amp;quot;ett&amp;quot;, &amp;quot;rftt&amp;quot; ] Output: &amp;quot;wertf&amp;quot;  Example 2:
Input: [ &amp;quot;z&amp;quot;, &amp;quot;x&amp;quot; ] Output: &amp;quot;zx&amp;quot;  Example 3:</description>
    </item>
    
    <item>
      <title>Install Java on Linux</title>
      <link>http://www.hashnopolis.com/post/2018/11/install-java-on-linux/</link>
      <pubDate>Tue, 20 Nov 2018 12:12:47 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/install-java-on-linux/</guid>
      <description>Install manually Step 1: Download the source package from the oracle repository. If your computer is 64-bit, download the x64 version; if it is 32-bit, download the x86 version.
Step 2: Extract from the compressed file and move the package folder to /usr/java. rememeber to run these commands as sudo is not the root user.
mv downloads-folder/jdk-&amp;lt;version&amp;gt;-linux-xxx.tar.gz /usr/java tar -xvzf jdk-&amp;lt;version&amp;gt;-linux-xxx.tar.gz rm jdk-&amp;lt;version&amp;gt;-linux-xxx.tar.gz  Step 3: Add the java path to the ~/.</description>
    </item>
    
  </channel>
</rss>