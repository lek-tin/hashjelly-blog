<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hashmap on Hashnopolis</title>
    <link>http://www.hashnopolis.com/tags/hashmap/</link>
    <description>Recent content in Hashmap on Hashnopolis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Hashnopolis</copyright>
    <lastBuildDate>Thu, 21 Nov 2019 22:24:06 -0800</lastBuildDate>
    
	<atom:link href="http://www.hashnopolis.com/tags/hashmap/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Longest Substring Without Repeating Characters</title>
      <link>http://www.hashnopolis.com/post/2019/11/longest-substring-without-repeating-characters/</link>
      <pubDate>Thu, 21 Nov 2019 22:24:06 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/11/longest-substring-without-repeating-characters/</guid>
      <description>Given a string, find the length of the longest substring without repeating characters.
*### Example 1
Input: &amp;quot;abcabcbb&amp;quot; Output: 3 Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3.  *### Example 2
Input: &amp;quot;bbbbb&amp;quot; Output: 1 Explanation: The answer is &amp;quot;b&amp;quot;, with the length of 1.  *### Example 3
Input: &amp;quot;pwwkew&amp;quot; Output: 3 Explanation: The answer is &amp;quot;wke&amp;quot;, with the length of 3. Note that the answer must be a substring, &amp;quot;pwke&amp;quot; is a subsequence and not a substring.</description>
    </item>
    
    <item>
      <title>Before and After Puzzle</title>
      <link>http://www.hashnopolis.com/post/2019/10/before-and-after-puzzle/</link>
      <pubDate>Fri, 25 Oct 2019 01:26:32 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/10/before-and-after-puzzle/</guid>
      <description>Given a list of phrases, generate a list of Before and After puzzles.
A phrase is a string that consists of lowercase English letters and spaces only. No space appears in the start or the end of a phrase. There are no consecutive spaces in a phrase.
Before and After puzzles are phrases that are formed by merging two phrases where the last word of the first phrase is the same as the first word of the second phrase.</description>
    </item>
    
    <item>
      <title>Verifying an Alien Dictionary</title>
      <link>http://www.hashnopolis.com/post/2019/09/verifying-an-alien-dictionary/</link>
      <pubDate>Thu, 26 Sep 2019 16:52:43 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/09/verifying-an-alien-dictionary/</guid>
      <description>In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.
Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language.
Example 1: Input: words = [&amp;quot;hello&amp;quot;,&amp;quot;leetcode&amp;quot;], order = &amp;quot;hlabcdefgijkmnopqrstuvwxyz&amp;quot; Output: true Explanation: As &#39;h&#39; comes before &#39;l&#39; in this language, then the sequence is sorted.</description>
    </item>
    
    <item>
      <title>Subarray Sum Equals K</title>
      <link>http://www.hashnopolis.com/post/2019/09/subarray-sum-equals-k/</link>
      <pubDate>Thu, 26 Sep 2019 15:33:32 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/09/subarray-sum-equals-k/</guid>
      <description> Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.
Example 1: Input:nums = [1,1,1], k = 2 Output: 2  Note:  The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].  Solution class Solution: def subarraySum(self, nums: List[int], k: int) -&amp;gt; int: n = len(nums) if not nums or n == 0: return 0 sums = [nums[0] for _ in range(n)] for i in range(1, n): sums[i] = sums[i-1] + nums[i] mapping = {0: 1} count = 0 for s in sums: if s-k in mapping: count += mapping[s-k] temp = 0 try: temp = mapping[s] + 1 except: temp = 1 mapping[s] = temp return count  </description>
    </item>
    
    <item>
      <title>Find Anagram Mappings</title>
      <link>http://www.hashnopolis.com/post/2019/09/find-anagram-mappings/</link>
      <pubDate>Tue, 17 Sep 2019 00:30:24 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/09/find-anagram-mappings/</guid>
      <description>Given two lists A and B, and B is an anagram of A. B is an anagram of A means B is made by randomizing the order of the elements in A.
We want to find an index mapping P, from A to B. A mapping P[i] = j means the ith element in A appears in B at index j.
These lists A and B may contain duplicates. If there are multiple answers, output any of them.</description>
    </item>
    
    <item>
      <title>Super Ugly Number</title>
      <link>http://www.hashnopolis.com/post/2019/09/super-ugly-number/</link>
      <pubDate>Sat, 14 Sep 2019 22:35:23 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/09/super-ugly-number/</guid>
      <description>Write a program to find the nth super ugly number.
Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k.
Example: Input: n = 12, primes = [2,7,13,19] Output: 32 Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19] of size 4.  Note:  1 is a super ugly number for any given primes.</description>
    </item>
    
    <item>
      <title>Longest Consecutive Sequence</title>
      <link>http://www.hashnopolis.com/post/2019/09/longest-consecutive-sequence/</link>
      <pubDate>Tue, 10 Sep 2019 12:01:01 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/09/longest-consecutive-sequence/</guid>
      <description> Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
Your algorithm should run in O(n) complexity.
Example Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.  Solution # Time: o(n) class Solution: def longestConsecutive(self, nums: List[int]) -&amp;gt; int: # Count occurence of nums mapping = {} for num in nums: mapping[num] = True # init longest length longest = 0 # iterate over nums for num in nums: if num in mapping: # num exists in mapping =&amp;gt; init l = 1 l = 1 # num was counted, so we delete num del mapping[num] left, right = num-1, num+1 # Move left while left in mapping: # left was counted, so we delete left del mapping[left] left -= 1 l += 1 # Move right while right in mapping: # right was counted, so we delete right del mapping[right] right += 1 l += 1 # Update longest longest = max(longest, l) return longest  </description>
    </item>
    
    <item>
      <title>Two Sum Iii Data Structure Design Design</title>
      <link>http://www.hashnopolis.com/post/2019/08/two-sum-iii-data-structure-design-design/</link>
      <pubDate>Tue, 20 Aug 2019 01:18:01 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/08/two-sum-iii-data-structure-design-design/</guid>
      <description>Design and implement a TwoSum class. It should support the following operations: add and find.
add - Add the number to an internal data structure. find - Find if there exists any pair of numbers which sum is equal to the value.
Example 1: add(1); add(3); add(5); find(4) -&amp;gt; true find(7) -&amp;gt; false  Example 2: add(3); add(1); add(2); find(3) -&amp;gt; true find(6) -&amp;gt; false  Solution # Time: add is o(1), find is o(n) # Space: o(n) class TwoSum: def __init__(self): &amp;quot;&amp;quot;&amp;quot; Initialize your data structure here.</description>
    </item>
    
    <item>
      <title>Two Sum</title>
      <link>http://www.hashnopolis.com/post/2019/08/two-sum/</link>
      <pubDate>Mon, 19 Aug 2019 00:44:49 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/08/two-sum/</guid>
      <description>Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].  Solution # time: o(n) # space: o(n) class Solution: def twoSum(self, nums, target): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :type target: int :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; res = [-1, -1] if nums == None or len(nums) &amp;lt; 2: return res solutionMap = {} for pos in range(len(nums) - 1): if (target - nums[pos]) in solutionMap: res[0] = solutionMap[target - nums[pos]] res[1] = pos break solutionMap[nums[pos]] = pos return res  # time: o(nlogn) # space: o(1) class Pair: def __init__(self, index, val): self.</description>
    </item>
    
    <item>
      <title>Copy List With Random Pointer</title>
      <link>http://www.hashnopolis.com/post/2019/08/copy-list-with-random-pointer/</link>
      <pubDate>Sun, 11 Aug 2019 23:34:11 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/08/copy-list-with-random-pointer/</guid>
      <description>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.
Return a deep copy of the list.
Solution Solution 1: Insert cloned nodes in between original nodes then connect the cloned nodes
# Definition for singly-linked list with a random pointer. # class RandomListNode(object): # def __init__(self, x): # self.label = x # self.next = None # self.</description>
    </item>
    
    <item>
      <title>Longest Substring With at Most Two Distinct Characters</title>
      <link>http://www.hashnopolis.com/post/2019/03/longest-substring-with-at-most-two-distinct-characters/</link>
      <pubDate>Sat, 16 Mar 2019 13:30:30 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/longest-substring-with-at-most-two-distinct-characters/</guid>
      <description>Given a string s, find the length of the longest substring t that contains at most 2 distinct characters.
Example 1: Input: &amp;quot;eceba&amp;quot; Output: 3 Explanation: t is &amp;quot;ece&amp;quot; which its length is 3.  Example 2: Input: &amp;quot;ccaabbb&amp;quot; Output: 5 Explanation: t is &amp;quot;aabbb&amp;quot; which its length is 5.  Solution class Solution { public int lengthOfLongestSubstringTwoDistinct(String s) { HashMap&amp;lt;Character, Integer&amp;gt; countMap = new HashMap&amp;lt;Character, Integer&amp;gt;(); int left = 0; int max = 0; for (int i = 0; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>Longest Substring With at Most K Distinct Characters</title>
      <link>http://www.hashnopolis.com/post/2019/03/longest-substring-with-at-most-k-distinct-characters/</link>
      <pubDate>Thu, 14 Mar 2019 01:03:53 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/longest-substring-with-at-most-k-distinct-characters/</guid>
      <description>Given a string, find the length of the longest substring T that contains at most k distinct characters.
Example 1: Input: s = &amp;quot;eceba&amp;quot;, k = 2 Output: 3 Explanation: T is &amp;quot;ece&amp;quot; which its length is 3.  Example 2: Input: s = &amp;quot;aa&amp;quot;, k = 1 Output: 2 Explanation: T is &amp;quot;aa&amp;quot; which its length is 2.  Solution class Solution { public int lengthOfLongestSubstringKDistinct(String s, int k) { Map&amp;lt;Character, Integer&amp;gt; countMap = new HashMap&amp;lt;&amp;gt;(); int left = 0; int max = 0; for(int i = 0; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>Maximum Frequency Stack</title>
      <link>http://www.hashnopolis.com/post/2019/03/maximum-frequency-stack/</link>
      <pubDate>Tue, 12 Mar 2019 03:52:37 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/maximum-frequency-stack/</guid>
      <description>Implement FreqStack, a class which simulates the operation of a stack-like data structure.
FreqStack has two functions:
1. push(int x), which pushes an integer x onto the stack.
2. pop(), which removes and returns the most frequent element in the stack.
3. If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.
Example 1: Input: [&amp;quot;FreqStack&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;pop&amp;quot;,&amp;quot;pop&amp;quot;,&amp;quot;pop&amp;quot;,&amp;quot;pop&amp;quot;], [[],[5],[7],[5],[7],[4],[5],[],[],[],[]] Output: [null,null,null,null,null,null,null,5,7,5,4] Explanation: After making six .</description>
    </item>
    
    <item>
      <title>Most Common Word</title>
      <link>http://www.hashnopolis.com/post/2019/03/most-common-word/</link>
      <pubDate>Thu, 07 Mar 2019 23:04:58 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/most-common-word/</guid>
      <description>Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn&amp;rsquo;t banned, and that the answer is unique.
Words in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The answer is in lowercase.</description>
    </item>
    
    <item>
      <title>Encode and Decode Tinyurl</title>
      <link>http://www.hashnopolis.com/post/2018/11/encode-and-decode-tinyurl/</link>
      <pubDate>Sun, 11 Nov 2018 18:48:12 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/encode-and-decode-tinyurl/</guid>
      <description>Note This is a companion problem to the System Design problem: Design TinyURL. TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk.
Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</description>
    </item>
    
    <item>
      <title>LRU Cache</title>
      <link>http://www.hashnopolis.com/post/2018/11/lru-cache/</link>
      <pubDate>Sun, 11 Nov 2018 15:33:09 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/lru-cache/</guid>
      <description>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.
get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</description>
    </item>
    
    <item>
      <title>Count Primes</title>
      <link>http://www.hashnopolis.com/post/2018/11/count-primes/</link>
      <pubDate>Fri, 09 Nov 2018 18:52:59 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/count-primes/</guid>
      <description>Count the number of prime numbers less than a non-negative number, n.
Example Input: 10 Output: 4  Explanation There are 4 prime numbers less than 10, they are 2, 3, 5, 7. Solution class Solution: def countPrimes(self, n): &amp;quot;&amp;quot;&amp;quot; :type n: int :rtype: int &amp;quot;&amp;quot;&amp;quot; if n &amp;lt;= 2: return 0 marked = [0] * (n-1) for i in range(int(n**0.5)+1): if marked[i] != 1: prime = i + 2 for j in range(prime**2-2, n-1, prime): marked[j] = 1 count = 0 for c, k in enumerate(marked): # We are counting numbers less than n, hence len(marked)-1 if k == 0 and c &amp;lt; len(marked)-1: count += 1 return count  Cleaner version</description>
    </item>
    
    <item>
      <title>Top K Frequent Elements</title>
      <link>http://www.hashnopolis.com/post/2018/09/top-k-frequent-elements/</link>
      <pubDate>Sun, 16 Sep 2018 15:04:30 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/top-k-frequent-elements/</guid>
      <description>Given a non-empty array of integers, return the k most frequent elements.
For example, Given [1,1,1,2,2,3] and k = 2, return [1,2].
Note You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm&amp;rsquo;s time complexity must be better than O(n log n), where n is the array&amp;rsquo;s size.
Solution class Solution: def topKFrequent(self, nums, k): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :type k: int :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; freqMap = dict() for num in nums: if freqMap.</description>
    </item>
    
    <item>
      <title>Valid Anagram</title>
      <link>http://www.hashnopolis.com/post/2018/09/valid-anagram/</link>
      <pubDate>Sat, 15 Sep 2018 12:53:21 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/valid-anagram/</guid>
      <description>Given two strings s and t , write a function to determine if t is an anagram of s.
Example 1:
Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; Output: true  Example 2:
Input: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot; Output: false  Note: You may assume the string contains only lowercase alphabets.
Follow-up What if the inputs contain unicode characters? How would you adapt your solution to such case?</description>
    </item>
    
    <item>
      <title>Roman to Integer</title>
      <link>http://www.hashnopolis.com/post/2018/09/roman-to-integer/</link>
      <pubDate>Sat, 15 Sep 2018 12:47:14 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/roman-to-integer/</guid>
      <description>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000  For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</description>
    </item>
    
  </channel>
</rss>