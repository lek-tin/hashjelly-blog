<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hashnopolis</title>
    <link>http://www.hashnopolis.com/post/</link>
    <description>Recent content in Posts on Hashnopolis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Hashnopolis</copyright>
    <lastBuildDate>Mon, 11 Mar 2019 01:36:25 -0700</lastBuildDate>
    
	<atom:link href="http://www.hashnopolis.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Design Tic Tac Toe</title>
      <link>http://www.hashnopolis.com/post/2019/03/design-tic-tac-toe/</link>
      <pubDate>Mon, 11 Mar 2019 01:36:25 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/design-tic-tac-toe/</guid>
      <description>Design a Tic-tac-toe game that is played between two players on a n x n grid.
You may assume the following rules: 1. A move is guaranteed to be valid and is placed on an empty block. 2. Once a winning condition is reached, no more moves is allowed. 3. A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.</description>
    </item>
    
    <item>
      <title>Boundary of Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2019/03/boundary-of-binary-tree/</link>
      <pubDate>Sun, 10 Mar 2019 23:31:42 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/boundary-of-binary-tree/</guid>
      <description>Given a binary tree, return the values of its boundary in anti-clockwise direction starting from root. Boundary includes left boundary, leaves, and right boundary in order without duplicate nodes.
Left boundary is defined as the path from root to the left-most node. Right boundary is defined as the path from root to the right-most node. If the root doesn&amp;rsquo;t have left subtree or right subtree, then the root itself is left boundary or right boundary.</description>
    </item>
    
    <item>
      <title>Serialize and Deserialize Bst</title>
      <link>http://www.hashnopolis.com/post/2019/03/serialize-and-deserialize-bst/</link>
      <pubDate>Sun, 10 Mar 2019 22:59:14 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/serialize-and-deserialize-bst/</guid>
      <description>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.</description>
    </item>
    
    <item>
      <title>Diameter of Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2019/03/diameter-of-binary-tree/</link>
      <pubDate>Sat, 09 Mar 2019 18:50:51 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/diameter-of-binary-tree/</guid>
      <description>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.
Example: Given a binary tree 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</description>
    </item>
    
    <item>
      <title>Kth Largest Element in a Stream</title>
      <link>http://www.hashnopolis.com/post/2019/03/kth-largest-element-in-a-stream/</link>
      <pubDate>Sat, 09 Mar 2019 02:08:26 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/kth-largest-element-in-a-stream/</guid>
      <description>Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream.</description>
    </item>
    
    <item>
      <title>Coin Change</title>
      <link>http://www.hashnopolis.com/post/2019/03/coin-change/</link>
      <pubDate>Fri, 08 Mar 2019 23:58:51 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/coin-change/</guid>
      <description>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.
Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1  Example 2: Input: coins = [2], amount = 3 Output: -1  Note: You may assume that you have an infinite number of each kind of coin.</description>
    </item>
    
    <item>
      <title>Most Common Word</title>
      <link>http://www.hashnopolis.com/post/2019/03/most-common-word/</link>
      <pubDate>Thu, 07 Mar 2019 23:04:58 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/most-common-word/</guid>
      <description>Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn&amp;rsquo;t banned, and that the answer is unique.
Words in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The answer is in lowercase.</description>
    </item>
    
    <item>
      <title>Graph and Tree Basics</title>
      <link>http://www.hashnopolis.com/post/2019/03/graph-and-tree-basics/</link>
      <pubDate>Thu, 07 Mar 2019 15:29:47 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/graph-and-tree-basics/</guid>
      <description>Tree: n - 1 edges, all nodes connected, contains no loop.</description>
    </item>
    
    <item>
      <title>Number of Connected Components in an Undirected Graph</title>
      <link>http://www.hashnopolis.com/post/2019/03/number-of-connected-components-in-an-undirected-graph/</link>
      <pubDate>Thu, 07 Mar 2019 11:40:26 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/number-of-connected-components-in-an-undirected-graph/</guid>
      <description>Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.
Example 1: Input: n = 5 and edges = [[0, 1], [1, 2], [3, 4]] 0 3 | | 1 --- 2 4 Output: 2  Example 2: Input: n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]] 0 4 | | 1 --- 2 --- 3 Output: 1  Note: You can assume that no duplicate edges will appear in edges.</description>
    </item>
    
    <item>
      <title>Graph Valid Tree</title>
      <link>http://www.hashnopolis.com/post/2019/03/graph-valid-tree/</link>
      <pubDate>Wed, 06 Mar 2019 23:46:04 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/graph-valid-tree/</guid>
      <description>Given n nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.
###Example 1:
Input: n = 5, and edges = [[0,1], [0,2], [0,3], [1,4]] Output: true  Example 2: Input: n = 5, and edges = [[0,1], [1,2], [2,3], [1,3], [1,4]] Output: false  ###Note: you can assume that no duplicate edges will appear in edges.</description>
    </item>
    
    <item>
      <title>Meeting Room</title>
      <link>http://www.hashnopolis.com/post/2019/03/meeting-room/</link>
      <pubDate>Sat, 02 Mar 2019 12:30:04 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/meeting-room/</guid>
      <description>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si &amp;lt; ei), determine if a person could attend all meetings.
Example 1: Input: [[0,30],[5,10],[15,20]] Output: false  Example 2: Input: [[7,10],[2,4]] Output: true  Solution /** * Definition for an interval. * public class Interval { * int start; * int end; * Interval() { start = 0; end = 0; } * Interval(int s, int e) { start = s; end = e; } * } */ class Solution { public boolean canAttendMeetings(Interval[] intervals) { Arrays.</description>
    </item>
    
    <item>
      <title>Unique Paths II</title>
      <link>http://www.hashnopolis.com/post/2019/03/unique-paths-ii/</link>
      <pubDate>Sat, 02 Mar 2019 12:24:17 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/unique-paths-ii/</guid>
      <description>A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below).
Now consider if some obstacles are added to the grids. How many unique paths would there be?</description>
    </item>
    
    <item>
      <title>Gas Station</title>
      <link>http://www.hashnopolis.com/post/2019/02/gas-station/</link>
      <pubDate>Thu, 28 Feb 2019 23:51:02 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/gas-station/</guid>
      <description>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].
You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.
Return the starting gas station&amp;rsquo;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</description>
    </item>
    
    <item>
      <title>Clone Graph</title>
      <link>http://www.hashnopolis.com/post/2019/02/clone-graph/</link>
      <pubDate>Wed, 27 Feb 2019 23:50:12 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/clone-graph/</guid>
      <description>Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.
Example: Input: {&amp;quot;$id&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$id&amp;quot;:&amp;quot;2&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;1&amp;quot;},{&amp;quot;$id&amp;quot;:&amp;quot;3&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;2&amp;quot;},{&amp;quot;$id&amp;quot;:&amp;quot;4&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;3&amp;quot;},{&amp;quot;$ref&amp;quot;:&amp;quot;1&amp;quot;}],&amp;quot;val&amp;quot;:4}],&amp;quot;val&amp;quot;:3}],&amp;quot;val&amp;quot;:2},{&amp;quot;$ref&amp;quot;:&amp;quot;4&amp;quot;}],&amp;quot;val&amp;quot;:1} Explanation: Node 1&#39;s value is 1, and it has two neighbors: Node 2 and 4. Node 2&#39;s value is 2, and it has two neighbors: Node 1 and 3. Node 3&#39;s value is 3, and it has two neighbors: Node 2 and 4.</description>
    </item>
    
    <item>
      <title>Largest Rectangle in Histogram</title>
      <link>http://www.hashnopolis.com/post/2019/02/largest-rectangle-in-histogram/</link>
      <pubDate>Mon, 25 Feb 2019 23:58:00 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/largest-rectangle-in-histogram/</guid>
      <description>Given n non-negative integers representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.
Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].
The largest rectangle is shown in the shaded area, which has area = 10 unit.
Example: Input: [2,1,5,6,2,3] Output: 10  Solution: Push height into the stack in ascending order.</description>
    </item>
    
    <item>
      <title>Maximal Rectangle</title>
      <link>http://www.hashnopolis.com/post/2019/02/maximal-rectangle/</link>
      <pubDate>Mon, 25 Feb 2019 00:41:33 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/maximal-rectangle/</guid>
      <description>Given a 2D binary matrix filled with 0&amp;rsquo;s and 1&amp;rsquo;s, find the largest rectangle containing only 1&amp;rsquo;s and return its area.
Example: Input: [ [&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;] ] Output: 6  Hint Height:
1 0 1 0 0 2 0 2 1 1 3 1 3 2 2 4 0 0 3 0  Left:
0 0 2 0 0 0 0 2 2 2 0 0 2 2 2 0 0 0 3 0  Right:</description>
    </item>
    
    <item>
      <title>House Robber III</title>
      <link>http://www.hashnopolis.com/post/2019/02/house-robber-iii/</link>
      <pubDate>Thu, 21 Feb 2019 20:56:55 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/house-robber-iii/</guid>
      <description>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the &amp;ldquo;root.&amp;rdquo; Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that &amp;ldquo;all houses in this place forms a binary tree&amp;rdquo;. It will automatically contact the police if two directly-linked houses were broken into on the same night.</description>
    </item>
    
    <item>
      <title>House Robber II</title>
      <link>http://www.hashnopolis.com/post/2019/02/house-robber-ii/</link>
      <pubDate>Thu, 21 Feb 2019 19:39:05 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/house-robber-ii/</guid>
      <description>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title>Best Meeting Point</title>
      <link>http://www.hashnopolis.com/post/2019/02/best-meeting-point/</link>
      <pubDate>Thu, 21 Feb 2019 10:15:51 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/best-meeting-point/</guid>
      <description>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.
Example: Input: 1 - 0 - 0 - 0 - 1 | | | | | 0 - 0 - 0 - 0 - 0 | | | | | 0 - 0 - 1 - 0 - 0 Output: 6  ###Explanation: Given three people living at (0,0), (0,4), and (2,2): The point (0,2) is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal.</description>
    </item>
    
    <item>
      <title>Maximum Subarray</title>
      <link>http://www.hashnopolis.com/post/2019/02/maximum-subarray/</link>
      <pubDate>Wed, 20 Feb 2019 22:30:14 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/maximum-subarray/</guid>
      <description>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.  Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
Solution: Iterative:
class Solution { public int maxSubArray(int[] nums) { if (nums.</description>
    </item>
    
    <item>
      <title>Intersection of Two Arrays II</title>
      <link>http://www.hashnopolis.com/post/2019/02/intersection-of-two-arrays-ii/</link>
      <pubDate>Mon, 18 Feb 2019 23:55:24 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/intersection-of-two-arrays-ii/</guid>
      <description>Given two arrays, write a function to compute their intersection.
Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2]  Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9]  Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order.
Follow up:  What if the given array is already sorted? How would you optimize your algorithm?</description>
    </item>
    
    <item>
      <title>Spiral Matrix</title>
      <link>http://www.hashnopolis.com/post/2019/02/spiral-matrix/</link>
      <pubDate>Sun, 17 Feb 2019 23:25:31 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/spiral-matrix/</guid>
      <description>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.
Example 1: Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5]  Example 2: Input: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7]  Solution: class Solution { public List&amp;lt;Integer&amp;gt; spiralOrder(int[][] matrix) { if (matrix == null || matrix.</description>
    </item>
    
    <item>
      <title>Palindrome Number</title>
      <link>http://www.hashnopolis.com/post/2019/02/palindrome-number/</link>
      <pubDate>Sun, 17 Feb 2019 22:07:48 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/palindrome-number/</guid>
      <description>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.
Example 1: Input: 121 Output: true  Example 2: Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.  Example 3: Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</description>
    </item>
    
    <item>
      <title>Longest Common Subsequence</title>
      <link>http://www.hashnopolis.com/post/2019/02/longest-common-subsequence/</link>
      <pubDate>Fri, 15 Feb 2019 17:28:18 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/longest-common-subsequence/</guid>
      <description>The longest common subsequence (LCS) problem is the problem of finding the longest subsequence common to all sequences in a set of sequences (often just two sequences). It differs from the longest common substring problem: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences.
Optimal Substructure: Let the input sequences be X[0..m-1] and Y[0..n-1] of lengths m and n respectively. And let L(X[0..m-1], Y[0..n-1]) be the length of LCS of the two sequences X and Y.</description>
    </item>
    
    <item>
      <title>Minimum Depth of Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2019/02/minimum-depth-of-binary-tree/</link>
      <pubDate>Tue, 12 Feb 2019 16:58:46 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/minimum-depth-of-binary-tree/</guid>
      <description>Given a binary tree, find its minimum depth.
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
Note: A leaf is a node with no children.
Example: Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7 return its minimum depth = 3.  Solution: /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Minimum Depth of Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2019/02/minimum-depth-of-binary-tree/</link>
      <pubDate>Tue, 12 Feb 2019 16:58:46 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/minimum-depth-of-binary-tree/</guid>
      <description>Given a binary tree, find its minimum depth.
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
Note: A leaf is a node with no children.
Example: Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7 return its minimum depth = 2.  Solution: /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Construct Binary Tree From Inorder and Postorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2019/02/construct-binary-tree-from-inorder-and-postorder-traversal/</link>
      <pubDate>Mon, 04 Feb 2019 23:50:51 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/02/construct-binary-tree-from-inorder-and-postorder-traversal/</guid>
      <description>Given inorder and postorder traversal of a tree, construct the binary tree.
Note: You may assume that duplicates do not exist in the tree.
For example, given
inorder = [9,3,15,20,7] postorder = [9,15,7,20,3]  Return the following binary tree:
 3 / \ 9 20 / \ 15 7  Solution: /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ // the idea is to start from the rightmst part of the postorder because that is always the root; then divide the inorder as per the value of the root call the right child first because after accesing the parent in postorder the right child is encountered first and then the left child class Solution { int postOrderIndex; public TreeNode buildTree(int[] inorder, int[] postorder) { postOrderIndex = postorder.</description>
    </item>
    
    <item>
      <title>Count Number of Substrings With K Distinct Characters</title>
      <link>http://www.hashnopolis.com/post/2019/01/count-number-of-substrings-with-k-distinct-characters/</link>
      <pubDate>Wed, 30 Jan 2019 00:56:00 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/count-number-of-substrings-with-k-distinct-characters/</guid>
      <description>Given a string, find the length of the longest substring T that contains at most k distinct characters.
Example 1:
Input: s = &amp;quot;eceba&amp;quot;, k = 2 Output: 5 Explanation: &amp;quot;ec&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;eb&amp;quot;, &amp;quot;ba&amp;quot; and &amp;quot;ece&amp;quot; k distinct characters.  Example 2:
Input: s = &amp;quot;aa&amp;quot;, k = 1 Output: 2 Explanation: &amp;quot;a&amp;quot; and &amp;quot;aa&amp;quot; have k distinct characters.  import java.util.Arrays; public class CountKSubStr { // Function to count number of substrings // with exactly k unique characters int countkDist(String str, int k) { // Initialize result int res = 0; int n = str.</description>
    </item>
    
    <item>
      <title>Construct Binary Tree From Preorder and Inorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2019/01/construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Mon, 28 Jan 2019 23:20:01 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>Given preorder and inorder traversal of a tree, construct the binary tree.
Note: You may assume that duplicates do not exist in the tree.
For example, given:
preorder = [3,9,20,15,7] inorder = [9,3,15,20,7]  Return the following binary tree:
 3 / \ 9 20 / \ 15 7  Solution: /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { return helper(0, 0, inorder.</description>
    </item>
    
    <item>
      <title>Trapping Rain Water</title>
      <link>http://www.hashnopolis.com/post/2019/01/trapping-rain-water/</link>
      <pubDate>Sat, 26 Jan 2019 23:39:49 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/trapping-rain-water/</guid>
      <description>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!
Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6  Solution: class Solution { public int trap(int[] height) { int n = height.</description>
    </item>
    
    <item>
      <title>Container With Most Water</title>
      <link>http://www.hashnopolis.com/post/2019/01/container-with-most-water/</link>
      <pubDate>Sat, 26 Jan 2019 23:38:02 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/container-with-most-water/</guid>
      <description>Given n non-negative integers a1, a2, &amp;hellip;, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7].</description>
    </item>
    
    <item>
      <title>Binary Tree Zigzag Level Order Traversal</title>
      <link>http://www.hashnopolis.com/post/2019/01/binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Fri, 25 Jan 2019 00:12:07 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/binary-tree-zigzag-level-order-traversal/</guid>
      <description>Given a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, then right to left for the next level and alternate between).
For example: Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  return its zigzag level order traversal as:
[ [3], [20,9], [15,7] ]  Solution::
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>String to Integer Atoi</title>
      <link>http://www.hashnopolis.com/post/2019/01/string-to-integer-atoi/</link>
      <pubDate>Thu, 24 Jan 2019 23:03:11 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/string-to-integer-atoi/</guid>
      <description>Implement atoi which converts a string to an integer.
The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.
The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</description>
    </item>
    
    <item>
      <title>Longest Common Prefix</title>
      <link>http://www.hashnopolis.com/post/2019/01/longest-common-prefix/</link>
      <pubDate>Wed, 23 Jan 2019 09:56:57 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/longest-common-prefix/</guid>
      <description>Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string &amp;ldquo;&amp;rdquo;.
Example 1:
Input: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] Output: &amp;quot;fl&amp;quot;  Example 2:
Input: [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;] Output: &amp;quot;&amp;quot; Explanation: There is no common prefix among the input strings.  Note: All given inputs are in lowercase letters a-z. Note:
# Time: O(n*l), l: number of strings class Solution(object): def longestCommonPrefix(self, strs): &amp;quot;&amp;quot;&amp;quot; :type strs: List[str] :rtype: str &amp;quot;&amp;quot;&amp;quot; if not strs or len(strs) == 0: return &amp;quot;&amp;quot; res = strs[0] for s in strs: # string.</description>
    </item>
    
    <item>
      <title>Longest Palindromic Substring</title>
      <link>http://www.hashnopolis.com/post/2019/01/longest-palindromic-substring/</link>
      <pubDate>Tue, 22 Jan 2019 22:29:56 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/longest-palindromic-substring/</guid>
      <description>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.
Example 1:
Input: &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Note: &amp;quot;aba&amp;quot; is also a valid answer.  Example 2:
Input: &amp;quot;cbbd&amp;quot; Output: &amp;quot;bb&amp;quot;  Solution: Dynamic Programming
# https://leetcode.com/problems/longest-palindromic-substring/discuss/157861/Python3-DP-Solution-with-Lots-of-Comments # time: O(n^2) # space: O(n^2) class Solution(object): def longestPalindrome(self, s): &amp;quot;&amp;quot;&amp;quot; :type s: str :rtype: str &amp;quot;&amp;quot;&amp;quot; str_len = len(s) if str_len == 0: return &amp;quot;&amp;quot; # Initialize DP table (dimensions: str_len x str_len) memo = [[False for i in range(str_len)] for j in range(str_len)] start = 0 # Starting index of the longest palindrome max_len = 1 # Length of the longest palindrome # Fill DP table for single char palindromes for i in range(str_len): memo[i][i] = True # Fill DP table for 2 char long palindromes for i in range(str_len - 1): j = i + 1 if s[i] == s[j]: memo[i][j] = True start = i max_len = 2 # Fill DP table for palindromes of every other length # starting from 3 length = 3 for length in range(3, str_len + 1): for i in range(str_len - length + 1): j = i + (length - 1) if s[i] == s[j] and memo[i+1][j-1]: memo[i][j] = True start = i max_len = length solution = s[start: start + max_len] return solution  Dynamic Programming</description>
    </item>
    
    <item>
      <title>Longest Substring Without Repeating Characters</title>
      <link>http://www.hashnopolis.com/post/2019/01/longest-substring-without-repeating-characters/</link>
      <pubDate>Tue, 22 Jan 2019 22:24:06 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/longest-substring-without-repeating-characters/</guid>
      <description>Given a string, find the length of the longest substring without repeating characters.
*Example 1:
Input: &amp;quot;abcabcbb&amp;quot; Output: 3 Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3.  *Example 2:
Input: &amp;quot;bbbbb&amp;quot; Output: 1 Explanation: The answer is &amp;quot;b&amp;quot;, with the length of 1.  *Example 3:
Input: &amp;quot;pwwkew&amp;quot; Output: 3 Explanation: The answer is &amp;quot;wke&amp;quot;, with the length of 3. Note that the answer must be a substring, &amp;quot;pwke&amp;quot; is a subsequence and not a substring.</description>
    </item>
    
    <item>
      <title>Add Two Numbers</title>
      <link>http://www.hashnopolis.com/post/2019/01/add-two-numbers/</link>
      <pubDate>Mon, 21 Jan 2019 23:38:03 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/add-two-numbers/</guid>
      <description>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example:
Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) Output: 7 -&amp;gt; 0 -&amp;gt; 8 Explanation: 342 + 465 = 807.</description>
    </item>
    
    <item>
      <title>Nvidia Cuda Architecture</title>
      <link>http://www.hashnopolis.com/post/2019/01/nvidia-cuda-architecture/</link>
      <pubDate>Fri, 18 Jan 2019 22:38:09 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/nvidia-cuda-architecture/</guid>
      <description>Fundamental concepts/components in the CUDA architecture:  thread:
 core/kernel:
 Block: a collection of parallel threads.
 Grid: a collection of parallel thread blocks.
 warp: a set of threads (commonly 32) that get executed simultaneously. Thread blocks are executed as smaller groups of threads known as &amp;ldquo;warps&amp;rdquo; in sequence. streaming multiprocessor: the number of blocks per grid is limited by SM. Waprs are scheduled to execute in SMs.</description>
    </item>
    
    <item>
      <title>Edit Distance</title>
      <link>http://www.hashnopolis.com/post/2019/01/edit-distance/</link>
      <pubDate>Thu, 17 Jan 2019 23:56:53 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/edit-distance/</guid>
      <description>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.
You have the following 3 operations permitted on a word: 1. Insert a character 2. Delete a character 3. Replace a character
Example 1: Input: word1 = &amp;quot;horse&amp;quot;, word2 = &amp;quot;ros&amp;quot; Output: 3 Explanation: horse -&amp;gt; rorse (replace &#39;h&#39; with &#39;r&#39;) rorse -&amp;gt; rose (remove &#39;r&#39;) rose -&amp;gt; ros (remove &#39;e&#39;)  Example 2: Input: word1 = &amp;quot;intention&amp;quot;, word2 = &amp;quot;execution&amp;quot; Output: 5 Explanation: intention -&amp;gt; inention (remove &#39;t&#39;) inention -&amp;gt; enention (replace &#39;i&#39; with &#39;e&#39;) enention -&amp;gt; exention (replace &#39;n&#39; with &#39;x&#39;) exention -&amp;gt; exection (replace &#39;n&#39; with &#39;c&#39;) exection -&amp;gt; execution (insert &#39;u&#39;)  Solution: class Solution { public int minDistance(String word1, String word2) { if (word1 == null || word2 == null) return -1; if (word1.</description>
    </item>
    
    <item>
      <title>Reverse Integer</title>
      <link>http://www.hashnopolis.com/post/2019/01/reverse-integer/</link>
      <pubDate>Wed, 16 Jan 2019 18:44:45 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/reverse-integer/</guid>
      <description>Given a 32-bit signed integer, reverse digits of an integer.
Example 1:
Input: 123 Output: 321  Example 2:
Input: -123 Output: -321  Example 3:
Input: 120 Output: 21  Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</description>
    </item>
    
    <item>
      <title>One Edit Distance</title>
      <link>http://www.hashnopolis.com/post/2019/01/one-edit-distance/</link>
      <pubDate>Wed, 16 Jan 2019 15:52:52 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/one-edit-distance/</guid>
      <description>Given two strings s and t, determine if they are both one edit distance apart.
Note: There are 3 possiblities to satisify one edit distance apart: 1. Insert a character into s to get t 2. Delete a character from s to get t 3. Replace a character of s to get t Example 1:
Input: s = &amp;quot;ab&amp;quot;, t = &amp;quot;acb&amp;quot; Output: true Explanation: We can insert &#39;c&#39; into s to get t.</description>
    </item>
    
    <item>
      <title>Find a Local Minima in an Array</title>
      <link>http://www.hashnopolis.com/post/2019/01/find-a-local-minima-in-an-array/</link>
      <pubDate>Mon, 14 Jan 2019 11:32:08 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/find-a-local-minima-in-an-array/</guid>
      <description>Given an array arr[0 .. n-1] of distinct integers, the task is to find a local minima in it. We say that an element arr[x] is a local minimum if it is less than or equal to both its neighbors.
For corner elements, we need to consider only one neighbor for comparison. There can be more than one local minima in an array, we need to find any one of them.</description>
    </item>
    
    <item>
      <title>Copy List With Random Pointer</title>
      <link>http://www.hashnopolis.com/post/2019/01/copy-list-with-random-pointer/</link>
      <pubDate>Mon, 07 Jan 2019 23:34:11 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/01/copy-list-with-random-pointer/</guid>
      <description>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.
Return a deep copy of the list.
Solution:
# Definition for singly-linked list with a random pointer. # class RandomListNode(object): # def __init__(self, x): # self.label = x # self.next = None # self.random = None class Solution(object): def copyRandomList(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: RandomListNode :rtype: RandomListNode &amp;quot;&amp;quot;&amp;quot; # corner case if head == None: return None # First pass: for each node in the original list, inset a copied node between the node tne node.</description>
    </item>
    
    <item>
      <title>Binary Tree Vertical Order Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/12/binary-tree-vertical-order-traversal/</link>
      <pubDate>Sun, 30 Dec 2018 22:43:56 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/12/binary-tree-vertical-order-traversal/</guid>
      <description>Given a binary tree, return the vertical order traversal of its nodes&amp;rsquo; values. (ie, from top to bottom, column by column).
If two nodes are in the same row and column, the order should be from left to right.
Examples 1:
Input: [3,9,20,null,null,15,7] 3 /\ / \ 9 20 /\ / \ 15 7 Output: [ [9], [3,15], [20], [7] ]  Examples 2:
Input: [3,9,8,4,0,1,7] 3 /\ / \ 9 8 /\ /\ / \/ \ 4 01 7 Output: [ [4], [9], [3,0,1], [8], [7] ]  Examples 3:</description>
    </item>
    
    <item>
      <title>Find K Closest Elements</title>
      <link>http://www.hashnopolis.com/post/2018/12/find-k-closest-elements/</link>
      <pubDate>Wed, 19 Dec 2018 16:00:58 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/12/find-k-closest-elements/</guid>
      <description>Given a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.
Example 1:
Input: [1,2,3,4,5], k=4, x=3 Output: [1,2,3,4]  Example 2:
Input: [1,2,3,4,5], k=4, x=-1 Output: [1,2,3,4]  Note: - The value k is positive and will always be smaller than the length of the sorted array.</description>
    </item>
    
    <item>
      <title>Longest Increasing Subsequence</title>
      <link>http://www.hashnopolis.com/post/2018/12/longest-increasing-subsequence/</link>
      <pubDate>Wed, 19 Dec 2018 10:47:57 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/12/longest-increasing-subsequence/</guid>
      <description>Given an unsorted array of integers, find the length of longest increasing subsequence.
Example:** Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.  Note:**  There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity?</description>
    </item>
    
    <item>
      <title>Longest Continuous Increasing Subsequence</title>
      <link>http://www.hashnopolis.com/post/2018/12/longest-continuous-increasing-subsequence/</link>
      <pubDate>Wed, 19 Dec 2018 10:40:26 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/12/longest-continuous-increasing-subsequence/</guid>
      <description>Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).
Example 1:
Input: [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. Even though [1,3,5,7] is also an increasing subsequence, it&#39;s not a continuous one where 5 and 7 are separated by 4.  Example 2:
Input: [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2], its length is 1.</description>
    </item>
    
    <item>
      <title>Find All Anagrams in a String</title>
      <link>http://www.hashnopolis.com/post/2018/12/find-all-anagrams-in-a-string/</link>
      <pubDate>Sat, 15 Dec 2018 09:42:45 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/12/find-all-anagrams-in-a-string/</guid>
      <description>Given a string s and a non-empty string p, find all the start indices of p&amp;rsquo;s anagrams in s.
Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.
The order of output does not matter.
Example 1:
Input: s: &amp;quot;cbaebabacd&amp;quot; p: &amp;quot;abc&amp;quot; Output: [0, 6] Explanation: The substring with start index = 0 is &amp;quot;cba&amp;quot;, which is an anagram of &amp;quot;abc&amp;quot;.</description>
    </item>
    
    <item>
      <title>Course Schedule</title>
      <link>http://www.hashnopolis.com/post/2018/12/course-schedule/</link>
      <pubDate>Sun, 09 Dec 2018 23:29:18 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/12/course-schedule/</guid>
      <description>There are a total of n courses you have to take, labeled from 0 to n-1.
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?
Example 1:
Input: 2, [[1,0]] Output: true Explanation: There are a total of 2 courses to take.</description>
    </item>
    
    <item>
      <title>Alien Dictionary</title>
      <link>http://www.hashnopolis.com/post/2018/12/alien-dictionary/</link>
      <pubDate>Sat, 08 Dec 2018 23:57:13 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/12/alien-dictionary/</guid>
      <description>There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.
Example 1:
Input: [ &amp;quot;wrt&amp;quot;, &amp;quot;wrf&amp;quot;, &amp;quot;er&amp;quot;, &amp;quot;ett&amp;quot;, &amp;quot;rftt&amp;quot; ] Output: &amp;quot;wertf&amp;quot;  Example 2:
Input: [ &amp;quot;z&amp;quot;, &amp;quot;x&amp;quot; ] Output: &amp;quot;zx&amp;quot;  Example 3:</description>
    </item>
    
    <item>
      <title>Random Pick Index</title>
      <link>http://www.hashnopolis.com/post/2018/12/random-pick-index/</link>
      <pubDate>Sat, 01 Dec 2018 22:27:00 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/12/random-pick-index/</guid>
      <description>Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.
Note: The array size can be very large. Solution that uses too much extra space will not pass the judge.
Example:
int[] nums = new int[] {1,2,3,3,3}; Solution solution = new Solution(nums); // pick(3) should return either index 2, 3, or 4 randomly.</description>
    </item>
    
    <item>
      <title>Intersection of Two Arrays</title>
      <link>http://www.hashnopolis.com/post/2018/11/intersection-of-two-arrays/</link>
      <pubDate>Wed, 28 Nov 2018 23:56:14 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/intersection-of-two-arrays/</guid>
      <description>Given two arrays, write a function to compute their intersection.
Example 1:
Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2]  Example 2:
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4]  Note: - Each element in the result must be unique. - The result can be in any order. Solution:
class Solution: def intersection(self, nums1, nums2): &amp;quot;&amp;quot;&amp;quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; res = set([]) dict1 = {} for n in nums1: if dict1.</description>
    </item>
    
    <item>
      <title>Useful Vim Commands</title>
      <link>http://www.hashnopolis.com/post/2018/11/useful-vim-commands/</link>
      <pubDate>Tue, 20 Nov 2018 21:40:20 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/useful-vim-commands/</guid>
      <description> :LINE_NUMBER: go to a line dd: delete a whole line :%d: delete all lines x: delete a char i: insert :set paste then paste: paste without auto indentation 0 move to beginning of the current line $ move to end of line H move to the top of the current window (high) M move to the middle of the current window (middle) L move to the bottom line of the current window (low) 1G move to the first line of the file 20G move to the 20th line of the file G move to the last line of the file  </description>
    </item>
    
    <item>
      <title>Install Java on Linux</title>
      <link>http://www.hashnopolis.com/post/2018/11/install-java-on-linux/</link>
      <pubDate>Tue, 20 Nov 2018 12:12:47 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/install-java-on-linux/</guid>
      <description>Install manually Step 1: Download the source package from the oracle repository. If your computer is 64-bit, download the x64 version; if it is 32-bit, download the x86 version.
Step 2: Extract from the compressed file and move the package folder to /usr/java. rememeber to run these commands as sudo is not the root user.
mv downloads-folder/jdk-&amp;lt;version&amp;gt;-linux-xxx.tar.gz /usr/java tar -xvzf jdk-&amp;lt;version&amp;gt;-linux-xxx.tar.gz rm jdk-&amp;lt;version&amp;gt;-linux-xxx.tar.gz  Step 3: Add the java path to the ~/.</description>
    </item>
    
    <item>
      <title>Read N Characters Given Read4</title>
      <link>http://www.hashnopolis.com/post/2018/11/read-n-characters-given-read4/</link>
      <pubDate>Mon, 19 Nov 2018 23:52:19 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/read-n-characters-given-read4/</guid>
      <description>The API: int read4(char *buf) reads 4 characters at a time from a file.
The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.
By using the read4 API, implement the function int read(char *buf, int n)that reads n characters from the file.
Example 1:
Input: buf = &amp;quot;abc&amp;quot;, n = 4 Output: &amp;quot;abc&amp;quot; Explanation: The actual number of characters read is 3, which is &amp;quot;abc&amp;quot;.</description>
    </item>
    
    <item>
      <title>Super Useful Bash Commands</title>
      <link>http://www.hashnopolis.com/post/2018/11/super-useful-bash-commands/</link>
      <pubDate>Mon, 19 Nov 2018 23:44:01 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/super-useful-bash-commands/</guid>
      <description>List all services
sudo service --status-all  Create a nested directory if it doesn&amp;rsquo;t exist already.
mkdir -p /nested/directory  To list detailed information about all items (visible and invisible) in the current directory (the -a option is to show all files, the -l option is to show details)
ls -al  To list the contents of your Documents folder and all sub folders (this may take a while if you have a large Documents folder)</description>
    </item>
    
    <item>
      <title>CPP Data Types</title>
      <link>http://www.hashnopolis.com/post/2018/11/cpp-data-types/</link>
      <pubDate>Sun, 18 Nov 2018 14:39:12 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/cpp-data-types/</guid>
      <description>https://stackoverflow.com/questions/2550345/whats-the-difference-between-unsigned-long-long-int-in-c-c
   Type Typical Bit Width Typical Range     char 1byte -127 to 127 or 0 to 255   unsigned char 1byte 0 to 255   signed char 1byte -127 to 127   int 4bytes -2147483648 to 2147483647   unsigned int 4bytes 0 to 4294967295   signed int 4bytes -2147483648 to 2147483647   short int 2bytes -32768 to 32767   unsigned short int Range 0 to 65,535   signed short int Range -32768 to 32767   long int 4bytes -2,147,483,648 to 2,147,483,647   signed long int 4bytes same as long int   unsigned long int 4bytes 0 to 4,294,967,295   float 4bytes +/- 3.</description>
    </item>
    
    <item>
      <title>Find the Celebrity</title>
      <link>http://www.hashnopolis.com/post/2018/11/find-the-celebrity/</link>
      <pubDate>Sun, 18 Nov 2018 14:19:34 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/find-the-celebrity/</guid>
      <description>Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.
Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: &amp;ldquo;Hi, A.</description>
    </item>
    
    <item>
      <title>Binary Numbers</title>
      <link>http://www.hashnopolis.com/post/2018/11/binary-numbers/</link>
      <pubDate>Sun, 18 Nov 2018 14:15:35 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/binary-numbers/</guid>
      <description>For a 8-bit number, there are two ways to represent number:
unsigned values 0 to 255
signed values range from -128 (-2^8 = 10000000) to 127 (2^8 - 1)
signed -128 = 10000000 signed -127 = 10000001 signed -1 = 11111111 signed 0 = 00000000 signed 127 = 01111111 signed 127 + (-127) = 10000001 + 01111111 = 0  If a number is assigned with value that is too big for it to hold, overflowing would happen, 2^32 = 4,294,967,296 is the largest unsigned 32 bit value.</description>
    </item>
    
    <item>
      <title>Longest Consecutive Sequence</title>
      <link>http://www.hashnopolis.com/post/2018/11/longest-consecutive-sequence/</link>
      <pubDate>Wed, 14 Nov 2018 12:01:01 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/longest-consecutive-sequence/</guid>
      <description>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
Your algorithm should run in O(n) complexity.
Example:
Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.  Solution:
# Time: o(n) class Solution(object): def longestConsecutive(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: int &amp;quot;&amp;quot;&amp;quot; if nums is None or len(nums) == 0: return 0 map = {} maxLen = 0; for num in nums: if num in map: # skip duplicates continue # initialize ranges low, upp = num, num if num - 1 in map: low = map.</description>
    </item>
    
    <item>
      <title>Arrays in Python</title>
      <link>http://www.hashnopolis.com/post/2018/11/arrays-in-python/</link>
      <pubDate>Tue, 13 Nov 2018 22:05:44 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/arrays-in-python/</guid>
      <description>Reverse an array: reversedArray = arr[::-1]</description>
    </item>
    
    <item>
      <title>Flatten Nested List Iterator</title>
      <link>http://www.hashnopolis.com/post/2018/11/flatten-nested-list-iterator/</link>
      <pubDate>Tue, 13 Nov 2018 20:03:07 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/flatten-nested-list-iterator/</guid>
      <description>Given a nested list of integers, implement an iterator to flatten it.
Each element is either an integer, or a list &amp;ndash; whose elements may also be integers or other lists.
Example 1:
Input: [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: `[1,1,2,1,1]`.  Example 2:
Input: [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: `[1,4,6]`.</description>
    </item>
    
    <item>
      <title>Reverse Nodes in K Group</title>
      <link>http://www.hashnopolis.com/post/2018/11/reverse-nodes-in-k-group/</link>
      <pubDate>Tue, 13 Nov 2018 18:04:36 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/reverse-nodes-in-k-group/</guid>
      <description>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
Example: Given this linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5
For k = 2, you should return: 2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5</description>
    </item>
    
    <item>
      <title>Serialize and Deserialize Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/serialize-and-deserialize-binary-tree/</link>
      <pubDate>Tue, 13 Nov 2018 17:31:13 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/serialize-and-deserialize-binary-tree/</guid>
      <description>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</description>
    </item>
    
    <item>
      <title>Remove Invalid Parentheses</title>
      <link>http://www.hashnopolis.com/post/2018/11/remove-invalid-parentheses/</link>
      <pubDate>Tue, 13 Nov 2018 16:20:10 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/remove-invalid-parentheses/</guid>
      <description>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.
Note: The input string may contain letters other than the parentheses ( and ).
*Example 1:
Input: &amp;quot;()())()&amp;quot; Output: [&amp;quot;()()()&amp;quot;, &amp;quot;(())()&amp;quot;]  *Example 2:
Input: &amp;quot;(a)())()&amp;quot; Output: [&amp;quot;(a)()()&amp;quot;, &amp;quot;(a())()&amp;quot;]  *Example 3:
Input: &amp;quot;)(&amp;quot; Output: [&amp;quot;&amp;quot;]  *Solution:
# Credit: # Credit: https://leetcode.com/problems/remove-invalid-parentheses/discuss/186597/Very-easy-to-understand-Python-DFS class Solution(object): def removeInvalidParentheses(self, s): &amp;quot;&amp;quot;&amp;quot; :type s: str :rtype: List[str] &amp;quot;&amp;quot;&amp;quot; res = [] self.</description>
    </item>
    
    <item>
      <title>Encode and Decode Tinyurl</title>
      <link>http://www.hashnopolis.com/post/2018/11/encode-and-decode-tinyurl/</link>
      <pubDate>Sun, 11 Nov 2018 18:48:12 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/encode-and-decode-tinyurl/</guid>
      <description>Note: This is a companion problem to the System Design problem: Design TinyURL. TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk.
Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</description>
    </item>
    
    <item>
      <title>Meeting Rooms II</title>
      <link>http://www.hashnopolis.com/post/2018/11/meeting-rooms-ii/</link>
      <pubDate>Sun, 11 Nov 2018 17:11:19 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/meeting-rooms-ii/</guid>
      <description>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si &amp;lt; ei), find the minimum number of conference rooms required.
Example 1:
Input: [[0, 30],[5, 10],[15, 20]] Output: 2  Example 2:
Input: [[7,10],[2,4]] Output: 1  Solution:
# Definition for an interval. # class Interval: # def __init__(self, s=0, e=0): # self.start = s # self.end = e # |____| |_______| # |_______| |____| # Number of meeting rooms: 2 class Solution(object): def minMeetingRooms(self, intervals): &amp;quot;&amp;quot;&amp;quot; :type intervals: List[Interval] :rtype: int &amp;quot;&amp;quot;&amp;quot; starts, ends = [], [] length = len(intervals) for i in range(length): starts.</description>
    </item>
    
    <item>
      <title>LRU Cache</title>
      <link>http://www.hashnopolis.com/post/2018/11/lru-cache/</link>
      <pubDate>Sun, 11 Nov 2018 15:33:09 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/lru-cache/</guid>
      <description>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.
get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</description>
    </item>
    
    <item>
      <title>Interger to English Words</title>
      <link>http://www.hashnopolis.com/post/2018/11/interger-to-english-words/</link>
      <pubDate>Sun, 11 Nov 2018 13:27:05 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/interger-to-english-words/</guid>
      <description>Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.
Example 1:
Input: 123 Output: &amp;quot;One Hundred Twenty Three&amp;quot;  Example 2:
Input: 12345 Output: &amp;quot;Twelve Thousand Three Hundred Forty Five&amp;quot;  Example 3:
Input: 1234567 Output: &amp;quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&amp;quot;  Example 4:
Input: 1234567891 Output: &amp;quot;One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One&amp;quot;  Solution:</description>
    </item>
    
    <item>
      <title>PowX N</title>
      <link>http://www.hashnopolis.com/post/2018/11/powx-n/</link>
      <pubDate>Sun, 11 Nov 2018 12:40:25 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/powx-n/</guid>
      <description>Example 1:
Input: 2.00000, 10 Output: 1024.00000  Example 2:
Input: 2.10000, 3 Output: 9.26100  Example 3:
Input: 2.00000, -2 Output: 0.25000  Explanation: 2-2 = 1&amp;frasl;22 = 1&amp;frasl;4 = 0.25 Note: - -100.0 &amp;lt; x &amp;lt; 100.0 - n is a 32-bit signed integer, within the range [−231, 231 − 1] Solution:
# Time: o(logN) # Space: o(n) class Solution: def myPow(self, x, n): &amp;quot;&amp;quot;&amp;quot; :type x: float :type n: int :rtype: float &amp;quot;&amp;quot;&amp;quot; if n &amp;gt; 0: return self.</description>
    </item>
    
    <item>
      <title>Validate Binary Search Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/validate-binary-search-tree/</link>
      <pubDate>Sat, 10 Nov 2018 22:50:21 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/validate-binary-search-tree/</guid>
      <description>Given a binary tree, determine if it is a valid binary search tree (BST).
Assume a BST is defined as follows: - The left subtree of a node contains only nodes with keys less than the node&amp;rsquo;s key. - The right subtree of a node contains only nodes with keys greater than the node&amp;rsquo;s key. - Both the left and right subtrees must also be binary search trees. Example 1:</description>
    </item>
    
    <item>
      <title>Arrays in CPP</title>
      <link>http://www.hashnopolis.com/post/2018/11/arrays-in-cpp/</link>
      <pubDate>Sat, 10 Nov 2018 13:50:30 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/arrays-in-cpp/</guid>
      <description>To get the number of elements in an array in C++:
sizeof(awesomeArray) = total number of bytes allocated for awesomeArray array. Divide it with the size of one element in the array will give you the number of elements in the array: sizeof(awesomeArray)/sizeof(awesomeArray[0])</description>
    </item>
    
    <item>
      <title>Count Primes</title>
      <link>http://www.hashnopolis.com/post/2018/11/count-primes/</link>
      <pubDate>Fri, 09 Nov 2018 18:52:59 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/count-primes/</guid>
      <description>Count the number of prime numbers less than a non-negative number, n.
Example:
Input: 10 Output: 4  Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7. Solution:
class Solution: def countPrimes(self, n): &amp;quot;&amp;quot;&amp;quot; :type n: int :rtype: int &amp;quot;&amp;quot;&amp;quot; if n &amp;lt;= 2: return 0 marked = [0] * (n-1) for i in range(int(n**0.5)+1): if marked[i] != 1: prime = i + 2 for j in range(prime**2-2, n-1, prime): marked[j] = 1 count = 0 for c, k in enumerate(marked): # We are counting numbers less than n, hence len(marked)-1 if k == 0 and c &amp;lt; len(marked)-1: count += 1 return count  </description>
    </item>
    
    <item>
      <title>Implement Trie Prefix Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/implement-trie-prefix-tree/</link>
      <pubDate>Thu, 08 Nov 2018 23:07:10 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/implement-trie-prefix-tree/</guid>
      <description>Implement a trie with insert, search, and startsWith methods.
Example:
Trie trie = new Trie(); trie.insert(&amp;quot;apple&amp;quot;); trie.search(&amp;quot;apple&amp;quot;); // returns true trie.search(&amp;quot;app&amp;quot;); // returns false trie.startsWith(&amp;quot;app&amp;quot;); // returns true trie.insert(&amp;quot;app&amp;quot;); trie.search(&amp;quot;app&amp;quot;); // returns true  Note: You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings. Solution:
# o(n) class TrieNode(): def __init__(self): self.children = {} self.isWholeWord = False class Trie: def __init__(self): &amp;quot;&amp;quot;&amp;quot; Initialize your data structure here.</description>
    </item>
    
    <item>
      <title>Excel Sheet Column Title</title>
      <link>http://www.hashnopolis.com/post/2018/11/excel-sheet-column-title/</link>
      <pubDate>Thu, 08 Nov 2018 22:42:24 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/excel-sheet-column-title/</guid>
      <description>Given a positive integer, return its corresponding column title as appear in an Excel sheet.
For example:
 1 -&amp;gt; A 2 -&amp;gt; B 3 -&amp;gt; C ... 26 -&amp;gt; Z 27 -&amp;gt; AA 28 -&amp;gt; AB ...  Example 1:
Input: 1 Output: &amp;quot;A&amp;quot;  Example 2:
Input: 28 Output: &amp;quot;AB&amp;quot;  Example 3:
Input: 701 Output: &amp;quot;ZY&amp;quot;  Solution:
class Solution: def convertToTitle(self, n): &amp;quot;&amp;quot;&amp;quot; :type n: int :rtype: str &amp;quot;&amp;quot;&amp;quot; digit = 1 res = &amp;quot;&amp;quot; while n &amp;gt; 0: # Because we start from A.</description>
    </item>
    
    <item>
      <title>Increasing Triplet Subsequence</title>
      <link>http://www.hashnopolis.com/post/2018/11/increasing-triplet-subsequence/</link>
      <pubDate>Thu, 08 Nov 2018 22:10:52 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/increasing-triplet-subsequence/</guid>
      <description>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.
Formally the function should:
Return true if there exists i, j, k such that arr[i] &amp;lt; arr[j] &amp;lt; arr[k] given 0 ≤ i &amp;lt; j &amp;lt; k ≤ n-1 else return false. Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.
Example 1:
Input: [1,2,3,4,5] Output: true  Example 2:</description>
    </item>
    
    <item>
      <title>Simplify Path</title>
      <link>http://www.hashnopolis.com/post/2018/11/simplify-path/</link>
      <pubDate>Thu, 08 Nov 2018 22:02:51 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/simplify-path/</guid>
      <description>Given an absolute path for a file (Unix-style), simplify it.
For example, path = &amp;quot;/home/&amp;quot;, =&amp;gt; &amp;quot;/home&amp;quot; path = &amp;quot;/a/./b/../../c/&amp;quot;, =&amp;gt; &amp;quot;/c&amp;quot; path = &amp;quot;/a/../../b/../c//.//&amp;quot;, =&amp;gt; &amp;quot;/c&amp;quot; path = &amp;quot;/a//b////c/d//././/..&amp;quot;, =&amp;gt; &amp;quot;/a/b/c&amp;quot;
In a UNIX-style file system, a period (&amp;lsquo;.&amp;rsquo;) refers to the current directory, so it can be ignored in a simplified path. Additionally, a double period (&amp;ldquo;..&amp;rdquo;) moves up a directory, so it cancels out whatever the last directory was.</description>
    </item>
    
    <item>
      <title>Sqrtx</title>
      <link>http://www.hashnopolis.com/post/2018/11/sqrtx/</link>
      <pubDate>Thu, 08 Nov 2018 21:59:03 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/sqrtx/</guid>
      <description>Implement int sqrt(int x).
Compute and return the square root of x, where x is guaranteed to be a non-negative integer.
Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.
Example 1:
Input: 4 Output: 2  Example 2:
Input: 8 Output: 2  Explanation: The square root of 8 is 2.82842&amp;hellip;, and since the decimal part is truncated, 2 is returned.</description>
    </item>
    
    <item>
      <title>Sort Colors</title>
      <link>http://www.hashnopolis.com/post/2018/11/sort-colors/</link>
      <pubDate>Wed, 07 Nov 2018 10:46:26 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/sort-colors/</guid>
      <description>Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.
Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
Note: You are not suppose to use the library&amp;rsquo;s sort function for this problem. Example:
Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2]  Follow up: 1.</description>
    </item>
    
    <item>
      <title>Missing Words</title>
      <link>http://www.hashnopolis.com/post/2018/11/missing-words/</link>
      <pubDate>Tue, 06 Nov 2018 17:03:07 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/missing-words/</guid>
      <description>Julia and Samantha are playing with strings. Julia has a string S, and Samantha has a string T which is a subsequence of string S. They are trying to find out what words are missing in T. Help Julia and Samantha to solve the problem. List all the missing words in T, such that inserting them at the appropriate positions in T, in the same order, results in the string S.</description>
    </item>
    
    <item>
      <title>Product of Array Except Self</title>
      <link>http://www.hashnopolis.com/post/2018/11/product-of-array-except-self/</link>
      <pubDate>Sat, 03 Nov 2018 16:41:47 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/product-of-array-except-self/</guid>
      <description>Given an array of n integers where n &amp;gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].
Solve it without division and in O(n).
For example, given [1,2,3,4], return [24,12,8,6].
Follow up: Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.</description>
    </item>
    
    <item>
      <title>Move Zeroes</title>
      <link>http://www.hashnopolis.com/post/2018/11/move-zeroes/</link>
      <pubDate>Sat, 03 Nov 2018 16:25:23 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/move-zeroes/</guid>
      <description>Given an array nums, write a function to move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements.
For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].
Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. Credits: Special thanks to @jianchao.</description>
    </item>
    
    <item>
      <title>Count and Say</title>
      <link>http://www.hashnopolis.com/post/2018/11/count-and-say/</link>
      <pubDate>Sat, 03 Nov 2018 16:07:54 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/count-and-say/</guid>
      <description>The count-and-say sequence is the sequence of integers with the first five terms as following:
 1 11 21 1211 111221 1 is read off as &amp;quot;one 1&amp;quot; or 11. 11 is read off as &amp;quot;two 1s&amp;quot; or 21. 21 is read off as &amp;quot;one 2, then one 1&amp;quot; or 1211.  Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</description>
    </item>
    
    <item>
      <title>Implement Strstr</title>
      <link>http://www.hashnopolis.com/post/2018/11/implement-strstr/</link>
      <pubDate>Sat, 03 Nov 2018 01:46:24 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/implement-strstr/</guid>
      <description>Implement strstr().
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example 1:
Input: haystack = &amp;quot;hello&amp;quot;, needle = &amp;quot;ll&amp;quot; Output: 2  Example 2:
Input: haystack = &amp;quot;aaaaa&amp;quot;, needle = &amp;quot;bba&amp;quot; Output: -1  Clarification:
What should we return when needle is an empty string? This is a great question to ask during an interview.
For the purpose of this problem, we will return 0 when needle is an empty string.</description>
    </item>
    
    <item>
      <title>Valid Parentheses</title>
      <link>http://www.hashnopolis.com/post/2018/11/valid-parentheses/</link>
      <pubDate>Fri, 02 Nov 2018 20:30:23 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/valid-parentheses/</guid>
      <description>Given a string containing just the characters &amp;lsquo;(&amp;rsquo;, &amp;lsquo;)&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, &amp;lsquo;}&amp;rsquo;, &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;, determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid.
Example 1:
Input: &amp;quot;()&amp;quot; Output: true  Example 2:
Input: &amp;quot;()[]{}&amp;quot; Output: true  Example 3:</description>
    </item>
    
    <item>
      <title>Maximal Square</title>
      <link>http://www.hashnopolis.com/post/2018/11/maximal-square/</link>
      <pubDate>Thu, 01 Nov 2018 23:18:11 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/maximal-square/</guid>
      <description>Given a 2D binary matrix filled with 0&amp;rsquo;s and 1&amp;rsquo;s, find the largest square containing only 1&amp;rsquo;s and return its area.
Example: Input:
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
Output: 4 Solution:
class Solution: def maximalSquare(self, matrix): &amp;quot;&amp;quot;&amp;quot; :type matrix: List[List[str]] :rtype: int &amp;quot;&amp;quot;&amp;quot; area = 0 if not matrix: return area # Edge case: single col matrix for i in range(len(matrix)): if matrix[i][0] == &amp;quot;1&amp;quot;: matrix[i][0] = 1 area = 1 # Edge case: single row matrix for i in range(len(matrix[0])): if matrix[0][i] == &amp;quot;1&amp;quot;: matrix[0][i] = 1 area = 1 for i in range(1, len(matrix)): for j in range(1, len(matrix[0])): if matrix[i][j] == &amp;quot;0&amp;quot;: matrix[i][j] = 0 continue localMin = min( int(matrix[i-1][j]), int(matrix[i-1][j-1]), int(matrix[i][j-1]) ) print(int(matrix[i-1][j]), int(matrix[i-1][j-1]), int(matrix[i][j-1])) matrix[i][j] = localMin + 1 if matrix[i][j] &amp;gt; area: area = matrix[i][j] return area**2  class Solution { public int maximalSquare(char[][] matrix) { if (matrix.</description>
    </item>
    
    <item>
      <title>Valid Palindrome</title>
      <link>http://www.hashnopolis.com/post/2018/11/valid-palindrome/</link>
      <pubDate>Thu, 01 Nov 2018 22:39:07 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/valid-palindrome/</guid>
      <description>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
Note: For the purpose of this problem, we define empty string as valid palindrome.
Example 1:
Input: &amp;quot;A man, a plan, a canal: Panama&amp;quot; Output: true  Example 2:
Input: &amp;quot;race a car&amp;quot; Output: false  Solution:
class Solution: def isPalindrome(self, s): &amp;quot;&amp;quot;&amp;quot; :type s: str :rtype: bool &amp;quot;&amp;quot;&amp;quot; if not s: return True head = 0 tail = len(s) - 1 while head &amp;lt;= tail: cHead, cTail = s[head], s[tail] if not cHead.</description>
    </item>
    
    <item>
      <title>Lowest Common Ancestor of a Binary Search Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-search-tree/</link>
      <pubDate>Thu, 01 Nov 2018 13:23:27 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-search-tree/</guid>
      <description>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5]</description>
    </item>
    
    <item>
      <title>Lowest Common Ancestor of a Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Thu, 01 Nov 2018 13:18:53 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the : “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]
 _______3______ / \ ___5__ ___1__  / \ / 6 _2 0 8 / 7 4 Example 1:</description>
    </item>
    
    <item>
      <title>Summary Ranges</title>
      <link>http://www.hashnopolis.com/post/2018/10/summary-ranges/</link>
      <pubDate>Wed, 31 Oct 2018 23:53:52 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/summary-ranges/</guid>
      <description>Given a sorted integer array without duplicates, return the summary of its ranges.
Example 1:
Input: [0,1,2,4,5,7] Output: [&amp;quot;0-&amp;gt;2&amp;quot;,&amp;quot;4-&amp;gt;5&amp;quot;,&amp;quot;7&amp;quot;] Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.  Example 2:
Input: [0,2,3,4,6,8,9] Output: [&amp;quot;0&amp;quot;,&amp;quot;2-&amp;gt;4&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;8-&amp;gt;9&amp;quot;] Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.  Solution:
class Solution: def summaryRanges(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: List[str] &amp;quot;&amp;quot;&amp;quot; if not nums: return [] ranges = [str(nums[0])] for i in range(len(nums)-1): if nums[i+1] == nums[i] + 1: print(ranges) ranges[len(ranges)-1] = ranges[len(ranges)-1].</description>
    </item>
    
    <item>
      <title>Search a 2D Matrix</title>
      <link>http://www.hashnopolis.com/post/2018/10/search-a-2d-matrix/</link>
      <pubDate>Tue, 30 Oct 2018 23:56:03 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/search-a-2d-matrix/</guid>
      <description>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: - Integers in each row are sorted from left to right. - The first integer of each row is greater than the last integer of the previous row. Example 1:
Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true  Example 2:</description>
    </item>
    
    <item>
      <title>Find the Duplicate Number</title>
      <link>http://www.hashnopolis.com/post/2018/10/find-the-duplicate-number/</link>
      <pubDate>Sat, 27 Oct 2018 10:34:19 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/find-the-duplicate-number/</guid>
      <description>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.
Example 1:
Input: [1,3,4,2,2] Output: 2  Example 2:
Input: [3,1,3,4,2] Output: 3  Note: You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space.</description>
    </item>
    
    <item>
      <title>H-Index</title>
      <link>http://www.hashnopolis.com/post/2018/10/h-index/</link>
      <pubDate>Sat, 27 Oct 2018 01:07:05 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/h-index/</guid>
      <description>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher&amp;rsquo;s h-index.
According to the definition of h-index on Wikipedia: &amp;ldquo;A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.&amp;rdquo;
Example:
Input: citations = [3,0,6,1,5] Output: 3  Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.</description>
    </item>
    
    <item>
      <title>Word Ladder</title>
      <link>http://www.hashnopolis.com/post/2018/10/word-ladder/</link>
      <pubDate>Sat, 27 Oct 2018 01:05:07 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/word-ladder/</guid>
      <description>Given two words (beginWord and endWord), and a dictionary&amp;rsquo;s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: 1. Only one letter can be changed at a time. 2. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: - Return 0 if there is no such transformation sequence. - All words have the same length. - All words contain only lowercase alphabetic characters.</description>
    </item>
    
    <item>
      <title>Invert Binary Tree</title>
      <link>http://www.hashnopolis.com/post/2018/10/invert-binary-tree/</link>
      <pubDate>Fri, 26 Oct 2018 23:12:09 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/invert-binary-tree/</guid>
      <description>Invert a binary tree.
 4 / \ 2 7 / \ / \ 1 3 6 9  to
 4 / \ 7 2 / \ / \ 9 6 3 1  Thoughts What if a node is NULL? A NULL has no children, so how to iterate deeper into the tree?
// Attempt // class Solution { // public: void swapNodes(*leftNode, *rightNode) { *temp = *leftNode; *leftNode = *rightNode; *rightNode = temp; return; } TreeNode* invertTree(TreeNode* root) { if (root == NULL) return invertTree(root-&amp;gt;left, ) } };  Solution:</description>
    </item>
    
    <item>
      <title>Integer to Roman</title>
      <link>http://www.hashnopolis.com/post/2018/10/integer-to-roman/</link>
      <pubDate>Fri, 26 Oct 2018 23:11:27 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/integer-to-roman/</guid>
      <description>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000  For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</description>
    </item>
    
    <item>
      <title>Find First and Last Position of Element in Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/10/find-first-and-last-position-of-element-in-sorted-array/</link>
      <pubDate>Fri, 26 Oct 2018 23:10:23 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/find-first-and-last-position-of-element-in-sorted-array/</guid>
      <description>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]  Example 2:
Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]  Solution:</description>
    </item>
    
    <item>
      <title>Search in Rotated Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/10/search-in-rotated-sorted-array/</link>
      <pubDate>Fri, 26 Oct 2018 23:08:49 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/search-in-rotated-sorted-array/</guid>
      <description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).
Example 1:
Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4  Example 2:</description>
    </item>
    
    <item>
      <title>First Bad Version</title>
      <link>http://www.hashnopolis.com/post/2018/10/first-bad-version/</link>
      <pubDate>Fri, 26 Oct 2018 23:07:46 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/first-bad-version/</guid>
      <description>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</description>
    </item>
    
    <item>
      <title>Minimum Path Sum</title>
      <link>http://www.hashnopolis.com/post/2018/10/minimum-path-sum/</link>
      <pubDate>Fri, 26 Oct 2018 23:04:31 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/minimum-path-sum/</guid>
      <description>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
Example:
Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7  Explanation: Because the path 1→3→1→1→1 minimizes the sum. Solution:
class Solution: def minPathSum(self, grid): &amp;quot;&amp;quot;&amp;quot; :type grid: List[List[int]] :rtype: int &amp;quot;&amp;quot;&amp;quot; for r in range(len(grid)): for c in range(len(grid[0])): if (r == 0 and c !</description>
    </item>
    
    <item>
      <title>House Robber</title>
      <link>http://www.hashnopolis.com/post/2018/10/house-robber/</link>
      <pubDate>Thu, 25 Oct 2018 23:45:32 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/house-robber/</guid>
      <description>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title>Happy Number</title>
      <link>http://www.hashnopolis.com/post/2018/10/happy-number/</link>
      <pubDate>Thu, 25 Oct 2018 23:44:12 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/happy-number/</guid>
      <description>Write an algorithm to determine if a number is &amp;ldquo;happy&amp;rdquo;.
A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</description>
    </item>
    
    <item>
      <title>Merge Two Sorted Lists</title>
      <link>http://www.hashnopolis.com/post/2018/10/merge-two-sorted-lists/</link>
      <pubDate>Thu, 25 Oct 2018 23:43:25 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/merge-two-sorted-lists/</guid>
      <description>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
Example:
Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4  Solution:
class Solution: def mergeTwoLists(self, l1, l2): &amp;quot;&amp;quot;&amp;quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; if l1 == None: return l2 if l2 == None: return l1 root = ListNode(0) temp = root while l1 and l2: if l1.</description>
    </item>
    
    <item>
      <title>Merge Two Binary Trees</title>
      <link>http://www.hashnopolis.com/post/2018/10/merge-two-binary-trees/</link>
      <pubDate>Thu, 25 Oct 2018 23:42:27 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/merge-two-binary-trees/</guid>
      <description>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.
You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</description>
    </item>
    
    <item>
      <title>Multiply Strings</title>
      <link>http://www.hashnopolis.com/post/2018/10/multiply-strings/</link>
      <pubDate>Thu, 25 Oct 2018 23:40:08 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/multiply-strings/</guid>
      <description>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.
Example 1:
Input: num1 = &amp;quot;2&amp;quot;, num2 = &amp;quot;3&amp;quot; Output: &amp;quot;6&amp;quot;  Example 2:
Input: num1 = &amp;quot;123&amp;quot;, num2 = &amp;quot;456&amp;quot; Output: &amp;quot;56088&amp;quot;  Note: - The length of both num1 and num2 is &amp;lt; 110. - Both num1 and num2 contain only digits 0-9. - Both num1 and num2 do not contain any leading zero, except the number 0 itself.</description>
    </item>
    
    <item>
      <title>Kth Smallest Element in a BST</title>
      <link>http://www.hashnopolis.com/post/2018/10/kth-smallest-element-in-a-bst/</link>
      <pubDate>Wed, 24 Oct 2018 23:39:48 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/kth-smallest-element-in-a-bst/</guid>
      <description>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.
Note:
You may assume k is always valid, 1 ≤ k ≤ BST&#39;s total elements.  Example 1:
Input: root = [3,1,4,null,2], k = 1 Output: 1  Example 2: ```` Input: root = [5,3,6,2,4,null,null,1], k = 3 Output: 3
**Follow up:** What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently?</description>
    </item>
    
    <item>
      <title>Kth Largest Element in an Array</title>
      <link>http://www.hashnopolis.com/post/2018/10/kth-largest-element-in-an-array/</link>
      <pubDate>Wed, 24 Oct 2018 23:38:20 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/kth-largest-element-in-an-array/</guid>
      <description>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Example 1: Input: [3,2,1,5,6,4] and k = 2 Output: 5  Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4  Note: You may assume k is always valid, 1 ≤ k ≤ array&#39;s length.
Solution: Average time complexity: O(n) if we don’t need the sorted output, otherwise O(n+kLogk)</description>
    </item>
    
    <item>
      <title>Group Anagrams</title>
      <link>http://www.hashnopolis.com/post/2018/10/group-anagrams/</link>
      <pubDate>Mon, 22 Oct 2018 12:01:59 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/group-anagrams/</guid>
      <description>Given an array of strings, group anagrams together.
Example:
Input: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;], Output: [ [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;], [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;], [&amp;quot;bat&amp;quot;] ]  Note: - All inputs will be in lowercase. - The order of your output does not matter. Solution:
class Solution(object): def groupAnagrams(self, strs): &amp;quot;&amp;quot;&amp;quot; :type strs: List[str] :rtype: List[List[str]] &amp;quot;&amp;quot;&amp;quot; primeNums = { &amp;quot;a&amp;quot;: 2, &amp;quot;b&amp;quot;: 3, &amp;quot;c&amp;quot;: 5, &amp;quot;d&amp;quot;: 7, &amp;quot;e&amp;quot;: 11, &amp;quot;f&amp;quot;: 13, &amp;quot;g&amp;quot;: 17, &amp;quot;h&amp;quot;: 19, &amp;quot;i&amp;quot;: 23, &amp;quot;j&amp;quot;: 29, &amp;quot;k&amp;quot;: 31, &amp;quot;m&amp;quot;: 37, &amp;quot;l&amp;quot;: 41, &amp;quot;n&amp;quot;: 43, &amp;quot;o&amp;quot;: 47, &amp;quot;p&amp;quot;: 53, &amp;quot;q&amp;quot;: 59, &amp;quot;r&amp;quot;: 61, &amp;quot;s&amp;quot;: 67, &amp;quot;t&amp;quot;: 71, &amp;quot;u&amp;quot;: 73, &amp;quot;v&amp;quot;: 79, &amp;quot;w&amp;quot;: 83, &amp;quot;x&amp;quot;: 89, &amp;quot;y&amp;quot;: 97, &amp;quot;z&amp;quot;: 101 } def encode(string): res = 1 for s in list(string): res *= primeNums[s] return res anagrams = {} for string in strs: code = encode(string) if anagrams.</description>
    </item>
    
    <item>
      <title>Linked List Cycle II</title>
      <link>http://www.hashnopolis.com/post/2018/10/linked-list-cycle-ii/</link>
      <pubDate>Sun, 21 Oct 2018 23:08:30 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/linked-list-cycle-ii/</guid>
      <description>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
Note: Do not modify the linked list.
Follow up: Can you solve it without using extra space? Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def detectCycle(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; if head == None: return None slow = head fast = head hasCycle = False while fast.</description>
    </item>
    
    <item>
      <title>Linked List Cycle</title>
      <link>http://www.hashnopolis.com/post/2018/10/linked-list-cycle/</link>
      <pubDate>Sun, 21 Oct 2018 23:07:55 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/linked-list-cycle/</guid>
      <description>Given a linked list, determine if it has a cycle in it.
Follow up: Can you solve it without using extra space? Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def hasCycle(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: bool &amp;quot;&amp;quot;&amp;quot; slow = head fast = head while fast: # fast reaches the end, no cycle was detected if fast and not fast.</description>
    </item>
    
    <item>
      <title>Compare Version Numbers</title>
      <link>http://www.hashnopolis.com/post/2018/10/compare-version-numbers/</link>
      <pubDate>Tue, 16 Oct 2018 23:26:46 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/compare-version-numbers/</guid>
      <description>Compare two version numbers version1 and version2. If version1 &amp;gt; version2 return 1; if version1 &amp;lt; version2 return -1;otherwise return 0.
You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not &amp;ldquo;two and a half&amp;rdquo; or &amp;ldquo;half way to version three&amp;rdquo;, it is the fifth second-level revision of the second first-level revision.</description>
    </item>
    
    <item>
      <title>Word Search</title>
      <link>http://www.hashnopolis.com/post/2018/10/word-search/</link>
      <pubDate>Mon, 15 Oct 2018 23:48:28 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/word-search/</guid>
      <description>Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where &amp;ldquo;adjacent&amp;rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
Example:
board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] Given word = &amp;quot;ABCCED&amp;quot;, return true. Given word = &amp;quot;SEE&amp;quot;, return true. Given word = &amp;quot;ABCB&amp;quot;, return false.</description>
    </item>
    
    <item>
      <title>Intersection of Two Linked Lists</title>
      <link>http://www.hashnopolis.com/post/2018/10/intersection-of-two-linked-lists/</link>
      <pubDate>Sun, 14 Oct 2018 23:56:47 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/intersection-of-two-linked-lists/</guid>
      <description>Write a program to find the node at which the intersection of two singly linked lists begins.
For example, the following two linked lists:
A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3  begin to intersect at node c1.
Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns.</description>
    </item>
    
    <item>
      <title>Min Stack</title>
      <link>http://www.hashnopolis.com/post/2018/10/min-stack/</link>
      <pubDate>Sun, 14 Oct 2018 23:55:15 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/min-stack/</guid>
      <description>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. - push(x) &amp;ndash; Push element x onto stack. - pop() &amp;ndash; Removes the element on top of the stack. - top() &amp;ndash; Get the top element. - getMin() &amp;ndash; Retrieve the minimum element in the stack. Example:
MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; Returns -3. minStack.pop(); minStack.top(); --&amp;gt; Returns 0. minStack.</description>
    </item>
    
    <item>
      <title>Word Break</title>
      <link>http://www.hashnopolis.com/post/2018/10/word-break/</link>
      <pubDate>Wed, 10 Oct 2018 23:57:15 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/word-break/</guid>
      <description>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.
Note: - The same word in the dictionary may be reused multiple times in the segmentation. - You may assume the dictionary does not contain duplicate words. Example 1:
Input: s = &amp;quot;leetcode&amp;quot;, wordDict = [&amp;quot;leet&amp;quot;, &amp;quot;code&amp;quot;] Output: true Explanation: Return true because &amp;quot;leetcode&amp;quot; can be segmented as &amp;quot;leet code&amp;quot;.</description>
    </item>
    
    <item>
      <title>Number of Islands</title>
      <link>http://www.hashnopolis.com/post/2018/10/number-of-islands/</link>
      <pubDate>Tue, 09 Oct 2018 23:52:32 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/number-of-islands/</guid>
      <description>Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
Example 1:
Input: 11110 11010 11000 00000 Output: 1  Example 2:
Input: 11000 11000 00100 00011 Output: 3  Solution:
class Solution: def numIslands(self, grid): &amp;quot;&amp;quot;&amp;quot; :type grid: List[List[str]] :rtype: int &amp;quot;&amp;quot;&amp;quot; # Edge cases if not grid or len(grid) == 0 or len(grid[0]) == 0: return 0 rows = len(grid) cols = len(grid[0]) count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == &amp;quot;1&amp;quot;: count += 1 self.</description>
    </item>
    
    <item>
      <title>Binary Tree Maximum Path Sum</title>
      <link>http://www.hashnopolis.com/post/2018/10/binary-tree-maximum-path-sum/</link>
      <pubDate>Tue, 09 Oct 2018 23:50:03 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/binary-tree-maximum-path-sum/</guid>
      <description>Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
Example 1:
Input: [1,2,3] 1 / \ 2 3 Output: 6  Example 2:
Input: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7 Output: 42  Solution:</description>
    </item>
    
    <item>
      <title>Subsets Ii</title>
      <link>http://www.hashnopolis.com/post/2018/10/subsets-ii/</link>
      <pubDate>Mon, 08 Oct 2018 13:04:14 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/subsets-ii/</guid>
      <description>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.
Example:
Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]  Solution:
# Time: o(2^n) # Space: o(n) class Solution(object): def subsetsWithDup(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: List[List[int]] &amp;quot;&amp;quot;&amp;quot; # Edge case if nums == None or len(nums) == 0: return [] # Sort the given numbers nums.</description>
    </item>
    
    <item>
      <title>Merge Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/10/merge-sorted-array/</link>
      <pubDate>Mon, 08 Oct 2018 13:03:08 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/merge-sorted-array/</guid>
      <description>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.
Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example:
Input:  nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3</description>
    </item>
    
    <item>
      <title>Decode Ways</title>
      <link>http://www.hashnopolis.com/post/2018/10/decode-ways/</link>
      <pubDate>Wed, 03 Oct 2018 23:49:00 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/decode-ways/</guid>
      <description>A message containing letters from A-Z is being encoded to numbers using the following mapping:
&amp;lsquo;A&amp;rsquo; -&amp;gt; 1 &amp;lsquo;B&amp;rsquo; -&amp;gt; 2 &amp;hellip; &amp;lsquo;Z&amp;rsquo; -&amp;gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it.
Example 1:
Input: &amp;quot;12&amp;quot; Output: 2 Explanation: It could be decoded as &amp;quot;AB&amp;quot; (1 2) or &amp;quot;L&amp;quot; (12).  Example 2:
Input: &amp;quot;226&amp;quot; Output: 3 Explanation: It could be decoded as &amp;quot;BZ&amp;quot; (2 26), &amp;quot;VF&amp;quot; (22 6), or &amp;quot;BBF&amp;quot; (2 2 6).</description>
    </item>
    
    <item>
      <title>Reverse Linked List</title>
      <link>http://www.hashnopolis.com/post/2018/10/reverse-linked-list/</link>
      <pubDate>Tue, 02 Oct 2018 23:51:13 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/reverse-linked-list/</guid>
      <description>Reverse a singly linked list.
Example:
Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL  Follow up:
A linked list can be reversed either iteratively or recursively. Could you implement both? Solution:
# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None # null 1 ---- 2 ---- 3 ---- 4 ---- 5 # prev curr after # prev curr after # https://www.youtube.com/watch?v=D7y_hoT_YZI class Solution: def reverseList(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; curr, prev, after = head, None, ListNode(None) while curr !</description>
    </item>
    
    <item>
      <title>Reverse Linked List II</title>
      <link>http://www.hashnopolis.com/post/2018/09/reverse-linked-list-ii/</link>
      <pubDate>Sun, 30 Sep 2018 22:19:41 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/reverse-linked-list-ii/</guid>
      <description>Reverse a linked list from position m to n. Do it in one-pass.
Note: 1 ≤ m ≤ n ≤ length of list.
Example:
Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4 Output: 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL  *Solution:**
class Solution: def reverseBetween(self, head, m, n): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :type m: int :type n: int :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; dummy = ListNode(None) dummy.next = head pre = dummy curr = dummy.next for i in range(1, m): curr = curr.</description>
    </item>
    
    <item>
      <title>Gray Code</title>
      <link>http://www.hashnopolis.com/post/2018/09/gray-code/</link>
      <pubDate>Tue, 25 Sep 2018 08:14:01 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/gray-code/</guid>
      <description>The gray code is a binary numeral system where two successive values differ in only one bit.
Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.
For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:
00 - 0 01 - 1 11 - 3 10 - 2  Note: For a given n, a gray code sequence is not uniquely defined.</description>
    </item>
    
    <item>
      <title>Add Digits</title>
      <link>http://www.hashnopolis.com/post/2018/09/add-digits/</link>
      <pubDate>Sun, 23 Sep 2018 23:18:25 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/add-digits/</guid>
      <description>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
For example:
Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.
Follow up: Could you do it without any loop/recursion in O(1) runtime?
Credits: Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</description>
    </item>
    
    <item>
      <title>Remove Duplicates From Sorted List II</title>
      <link>http://www.hashnopolis.com/post/2018/09/remove-duplicates-from-sorted-list-ii/</link>
      <pubDate>Wed, 19 Sep 2018 10:38:38 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/remove-duplicates-from-sorted-list-ii/</guid>
      <description>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.
Example 1:
Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 Output: 1-&amp;gt;2-&amp;gt;5  Example 2:
Input: 1-&amp;gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3 Output: 2-&amp;gt;3  </description>
    </item>
    
    <item>
      <title>Remove Linked List Elements</title>
      <link>http://www.hashnopolis.com/post/2018/09/remove-linked-list-elements/</link>
      <pubDate>Tue, 18 Sep 2018 16:07:09 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/remove-linked-list-elements/</guid>
      <description>Remove all elements from a linked list of integers that have value val.
Example:
Input: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6 Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5  Solution:
# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def removeElements(self, head, val): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :type val: int :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; pre = ListNode(0) pre.next = head pos = pre while pos.next !</description>
    </item>
    
    <item>
      <title>Unique Binary Search Trees</title>
      <link>http://www.hashnopolis.com/post/2018/09/unique-binary-search-trees/</link>
      <pubDate>Sun, 16 Sep 2018 15:06:01 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/unique-binary-search-trees/</guid>
      <description>Given n, how many structurally unique BST&amp;rsquo;s (binary search trees) that store values 1 &amp;hellip; n?
Example:
Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST&#39;s: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3  Exaplanation:
n = 3 root: 1 left: 0 right: 2 f(0)*f(2); root: 2 left: 1 right: 1 f(1)*f(1); root: 3 left: 2 right: 0 f(2)*f(0);  Solution:</description>
    </item>
    
    <item>
      <title>Symmetric Tree</title>
      <link>http://www.hashnopolis.com/post/2018/09/symmetric-tree/</link>
      <pubDate>Sun, 16 Sep 2018 15:05:12 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/symmetric-tree/</guid>
      <description>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
For example, this binary tree [1,2,2,3,4,4,3] is symmetric:
 1 / \ 2 2 / \ / \ 3 4 4 3  But the following [1,2,2,null,3,null,3] is not:
 1 / \ 2 2 \ \ 3 3  Note: Bonus points if you could solve it both recursively and iteratively.
Solution:</description>
    </item>
    
    <item>
      <title>Top K Frequent Elements</title>
      <link>http://www.hashnopolis.com/post/2018/09/top-k-frequent-elements/</link>
      <pubDate>Sun, 16 Sep 2018 15:04:30 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/top-k-frequent-elements/</guid>
      <description>Given a non-empty array of integers, return the k most frequent elements.
For example, Given [1,1,1,2,2,3] and k = 2, return [1,2]. Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm&amp;rsquo;s time complexity must be better than O(n log n), where n is the array&amp;rsquo;s size. Solution:
class Solution: def topKFrequent(self, nums, k): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :type k: int :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; freqMap = dict() for num in nums: if freqMap.</description>
    </item>
    
    <item>
      <title>Same Tree</title>
      <link>http://www.hashnopolis.com/post/2018/09/same-tree/</link>
      <pubDate>Sun, 16 Sep 2018 15:03:53 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/same-tree/</guid>
      <description>Given two binary trees, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical and the nodes have the same value.
Example 1:
Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] Output: true  Example 2:
Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false  Example 3:
Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2] Output: false  Solution</description>
    </item>
    
    <item>
      <title>Remove Element</title>
      <link>http://www.hashnopolis.com/post/2018/09/remove-element/</link>
      <pubDate>Sun, 16 Sep 2018 15:02:20 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/remove-element/</guid>
      <description>Given an array nums and a value val, remove all instances of that value in-place and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
The order of elements can be changed. It doesn&amp;rsquo;t matter what you leave beyond the new length.
Example 1:
Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2.</description>
    </item>
    
    <item>
      <title>Remove Duplicates From Sorted List</title>
      <link>http://www.hashnopolis.com/post/2018/09/remove-duplicates-from-sorted-list/</link>
      <pubDate>Sun, 16 Sep 2018 15:01:24 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/remove-duplicates-from-sorted-list/</guid>
      <description>Given a sorted linked list, delete all duplicates such that each element appear only once.
Example 1:
Input: 1-&amp;gt;1-&amp;gt;2 Output: 1-&amp;gt;2  Example 2:
Input: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3  Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def deleteDuplicates(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; curr = head while curr != None and curr.</description>
    </item>
    
    <item>
      <title>Power of Two</title>
      <link>http://www.hashnopolis.com/post/2018/09/power-of-two/</link>
      <pubDate>Sat, 15 Sep 2018 12:56:41 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/power-of-two/</guid>
      <description>Given an integer, write a function to determine if it is a power of two.
Example 1:
Input: 1 Output: true Explanation: 2**0 = 1  Example 2:
Input: 16 Output: true Explanation: 2**4 = 16  Example 3:
Input: 218 Output: false  Solution:
class Solution: def isPowerOfTwo(self, n): &amp;quot;&amp;quot;&amp;quot; :type n: int :rtype: bool &amp;quot;&amp;quot;&amp;quot; if n == 0: return False if n &amp;amp; (n - 1) == 0: return True return False  </description>
    </item>
    
    <item>
      <title>Plus One</title>
      <link>http://www.hashnopolis.com/post/2018/09/plus-one/</link>
      <pubDate>Sat, 15 Sep 2018 12:56:08 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/plus-one/</guid>
      <description>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.
The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.
You may assume the integer does not contain any leading zero, except the number 0 itself.
Example 1:
Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.</description>
    </item>
    
    <item>
      <title>Swap Nodes in Pairs</title>
      <link>http://www.hashnopolis.com/post/2018/09/swap-nodes-in-pairs/</link>
      <pubDate>Sat, 15 Sep 2018 12:55:20 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/swap-nodes-in-pairs/</guid>
      <description>Given a linked list, swap every two adjacent nodes and return its head.
Example:
Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.  Note: - Your algorithm should use only constant extra space. - You may not modify the values in the list&amp;rsquo;s nodes, only nodes itself may be changed. Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def swapPairs(self, head): &amp;quot;&amp;quot;&amp;quot; :type head: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; # https://www.</description>
    </item>
    
    <item>
      <title>Unique Paths</title>
      <link>http://www.hashnopolis.com/post/2018/09/unique-paths/</link>
      <pubDate>Sat, 15 Sep 2018 12:54:17 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/unique-paths/</guid>
      <description>A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below).
How many possible unique paths are there?
Above is a 7 x 3 grid. How many possible unique paths are there?</description>
    </item>
    
    <item>
      <title>Valid Anagram</title>
      <link>http://www.hashnopolis.com/post/2018/09/valid-anagram/</link>
      <pubDate>Sat, 15 Sep 2018 12:53:21 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/valid-anagram/</guid>
      <description>Given two strings s and t , write a function to determine if t is an anagram of s.
Example 1:
Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; Output: true  Example 2:
Input: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot; Output: false  Note: You may assume the string contains only lowercase alphabets.
Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?</description>
    </item>
    
    <item>
      <title>Ugly Number</title>
      <link>http://www.hashnopolis.com/post/2018/09/ugly-number/</link>
      <pubDate>Sat, 15 Sep 2018 12:52:53 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/ugly-number/</guid>
      <description>Write a program to check whether a given number is an ugly number.
Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.
Example 1:
Input: 6 Output: true Explanation: 6 = 2 × 3  Example 2:
Input: 8 Output: true Explanation: 8 = 2 × 2 × 2  Example 3:
Input: 14 Output: false Explanation: 14 is not ugly since it includes another prime factor 7.</description>
    </item>
    
    <item>
      <title>Subsets</title>
      <link>http://www.hashnopolis.com/post/2018/09/subsets/</link>
      <pubDate>Sat, 15 Sep 2018 12:48:42 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/subsets/</guid>
      <description>Given a set of distinct integers, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.
Example:
Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]  Solution:
# Time: o(2^n) # Space: o(n) class Solution: def subsets(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: List[List[int]] &amp;quot;&amp;quot;&amp;quot; res = [] def dfs(nums, index, path): res.append(path) for i in range(index, len(nums)): dfs(nums, i+1, path+[nums[i]]) dfs(sorted(nums), 0, []) return res # or class Solution(object): def subsets(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: List[List[int]] &amp;quot;&amp;quot;&amp;quot; # Edge case if nums == None or len(nums) == 0: return [] # Sort the given numbers nums.</description>
    </item>
    
    <item>
      <title>Roman to Integer</title>
      <link>http://www.hashnopolis.com/post/2018/09/roman-to-integer/</link>
      <pubDate>Sat, 15 Sep 2018 12:47:14 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/roman-to-integer/</guid>
      <description>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000  For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</description>
    </item>
    
    <item>
      <title>Single Number III</title>
      <link>http://www.hashnopolis.com/post/2018/09/single-number-iii/</link>
      <pubDate>Fri, 14 Sep 2018 11:54:43 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/single-number-iii/</guid>
      <description>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.
For example: Given nums = [1, 2, 1, 3, 2, 5], return [3, 5]. Note:
 The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity.</description>
    </item>
    
    <item>
      <title>Single Number II</title>
      <link>http://www.hashnopolis.com/post/2018/09/single-number-ii/</link>
      <pubDate>Fri, 14 Sep 2018 11:53:51 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/single-number-ii/</guid>
      <description>Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,3,2] Output: 3  Example 2:
Input: [0,1,0,1,0,1,99] Output: 99  Solution:
class Solution: def singleNumber(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: int &amp;quot;&amp;quot;&amp;quot; # https://www.cnblogs.com/ganganloveu/p/4110996.html # https://blog.csdn.net/karen0310/article/details/78226261 ones, twos = 0, 0 for _, num in enumerate(nums): ones = (ones ^ num) &amp;amp; ~twos twos = (twos ^ num) &amp;amp; ~ones print(bin(num), &amp;quot;ones: &amp;quot;, bin(ones), &amp;quot;twos: &amp;quot;, bin(twos)) return ones  </description>
    </item>
    
    <item>
      <title>Single Number</title>
      <link>http://www.hashnopolis.com/post/2018/09/single-number/</link>
      <pubDate>Fri, 14 Sep 2018 11:53:00 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/single-number/</guid>
      <description> Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,1] Output: 1 Example 2:  Input: [4,1,2,1,2] Output: 4  Solution:
// Java class Solution { public int singleNumber(int[] nums) { int result=0; for(int num : nums) { result=result^num; } return result; } }  </description>
    </item>
    
    <item>
      <title>Find Peak Element</title>
      <link>http://www.hashnopolis.com/post/2018/09/find-peak-element/</link>
      <pubDate>Fri, 14 Sep 2018 11:51:46 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/find-peak-element/</guid>
      <description>A peak element is an element that is greater than its neighbors.
Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
You may imagine that nums[-1] = nums[n] = -∞.
Example 1:
Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.</description>
    </item>
    
    <item>
      <title>Find Minimum in Rotated Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/09/find-minimum-in-rotated-sorted-array/</link>
      <pubDate>Fri, 14 Sep 2018 11:50:46 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/find-minimum-in-rotated-sorted-array/</guid>
      <description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
Find the minimum element.
You may assume no duplicate exists in the array.
Example 1:
Input: [3,4,5,1,2] Output: 1  Example 2:
Input: [4,5,6,7,0,1,2] Output: 0  Solution:
class Solution: def findMin(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: int &amp;quot;&amp;quot;&amp;quot; if len(nums) == 1: return nums[0] if len(nums) == 2: return min(nums[0], nums[1]) if nums[0] &amp;lt; nums[len(nums)-1]: return nums[0] if nums[len(nums)-2] &amp;gt; nums[len(nums)-1]: return nums[len(nums)-1] for i in range(1, len(nums)-1): if nums[i] &amp;lt; nums[i-1] and nums[i] &amp;lt; nums[i+1]: return nums[i] def bsFindMin(self, nums): l, r = 0, len(nums) - 1 while l &amp;lt; r: m = (l + r) // 2 if nums[m] &amp;gt; nums[m - 1] and nums[m] &amp;gt; nums[m + 1]: return nums[m + 1] if nums[m] &amp;lt; nums[m - 1] and nums[m] &amp;lt; nums[m + 1]: return nums[m] if nums[m] &amp;gt;= nums[r]: l = m else: r = m return nums[0]  </description>
    </item>
    
    <item>
      <title>Delete Node in a Linked List</title>
      <link>http://www.hashnopolis.com/post/2018/09/delete-node-in-a-linked-list/</link>
      <pubDate>Fri, 14 Sep 2018 11:49:07 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/delete-node-in-a-linked-list/</guid>
      <description>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.
Supposed the linked list is 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 and you are given the third node with value 3, the linked list should become 1 -&amp;gt; 2 -&amp;gt; 4 after calling your function.
Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Convert Sorted Array to Binary Search Tree</title>
      <link>http://www.hashnopolis.com/post/2018/09/convert-sorted-array-to-binary-search-tree/</link>
      <pubDate>Fri, 14 Sep 2018 10:23:36 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/convert-sorted-array-to-binary-search-tree/</guid>
      <description>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
Example:
Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5  Solution:</description>
    </item>
    
    <item>
      <title>Binary Tree Right Side View</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-right-side-view/</link>
      <pubDate>Thu, 13 Sep 2018 23:03:06 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-right-side-view/</guid>
      <description>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.
Example:
Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 &amp;lt;--- / \ 2 3 &amp;lt;--- \ \ 5 4 &amp;lt;---  Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.</description>
    </item>
    
    <item>
      <title>Binary Tree Preorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-preorder-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 23:02:11 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-preorder-traversal/</guid>
      <description>Given a binary tree, return the preorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,2,3]  Follow up: Recursive solution is trivial, could you do it iteratively?
Solution:
# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def preorderTraversal_1(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; if root is None: return [] return [root.</description>
    </item>
    
    <item>
      <title>Binary Tree Postorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-postorder-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 23:01:30 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-postorder-traversal/</guid>
      <description>Given a binary tree, return the postorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [3,2,1]  Follow up:
Recursive solution is trivial, could you do it iteratively?
Solution:
Recursive👇
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def postorderTraversal(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; def traverse(node): if node == None: return [] return traverse(node.</description>
    </item>
    
    <item>
      <title>Binary Tree Paths</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-paths/</link>
      <pubDate>Thu, 13 Sep 2018 23:00:42 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-paths/</guid>
      <description>Given a binary tree, return all root-to-leaf paths.
Note: A leaf is a node with no children.
Example:
Input: 1 / \ 2 3 \ 5 Output: [&amp;quot;1-&amp;gt;2-&amp;gt;5&amp;quot;, &amp;quot;1-&amp;gt;3&amp;quot;]  Explanation: All root-to-leaf paths are: 1-&amp;gt;2-&amp;gt;5, 1-&amp;gt;3
Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def binaryTreePaths(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[str] &amp;quot;&amp;quot;&amp;quot; res = [] def traverse(root, path): if root == None: return path += str(root.</description>
    </item>
    
    <item>
      <title>Binary Tree Level Order Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 22:59:49 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal/</guid>
      <description>Given a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level).
For example:
Given binary tree `[3,9,20,null,null,15,7]`, 3 / \ 9 20 / \ 15 7  return its level order traversal as:
[ [3], [9,20], [15,7] ]  Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.</description>
    </item>
    
    <item>
      <title>Binary Tree Level Order Traversal II</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal-ii/</link>
      <pubDate>Thu, 13 Sep 2018 22:59:17 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-level-order-traversal-ii/</guid>
      <description>Given a binary tree, return the bottom-up level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level from leaf to root).
For example: Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  return its bottom-up level order traversal as:
[ [15,7], [9,20], [3] ]  Solution:
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Binary Tree Inorder Traversal</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-tree-inorder-traversal/</link>
      <pubDate>Thu, 13 Sep 2018 22:57:42 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-tree-inorder-traversal/</guid>
      <description>Given a binary tree, return the inorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,3,2]  Follow up: the Recursive solution is trivial, could you do it iteratively?
Solution
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def inorderTraversal(self, root): &amp;quot;&amp;quot;&amp;quot; :type root: TreeNode :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot;Check root == None to reduce time on checking&amp;quot;&amp;quot;&amp;quot; if root == None: return [] stack = [] result = [] current = root while (current!</description>
    </item>
    
    <item>
      <title>Employees Earning More Than Their Managers</title>
      <link>http://www.hashnopolis.com/post/2018/09/employees-earning-more-than-their-managers/</link>
      <pubDate>Wed, 12 Sep 2018 23:57:13 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/employees-earning-more-than-their-managers/</guid>
      <description># SQL Schema: Create table If Not Exists Employee (Id int, Name varchar(255), Salary int, ManagerId int) Truncate table Employee insert into Employee (Id, Name, Salary, ManagerId) values (&#39;1&#39;, &#39;Joe&#39;, &#39;70000&#39;, &#39;3&#39;) insert into Employee (Id, Name, Salary, ManagerId) values (&#39;2&#39;, &#39;Henry&#39;, &#39;80000&#39;, &#39;4&#39;) insert into Employee (Id, Name, Salary, ManagerId) values (&#39;3&#39;, &#39;Sam&#39;, &#39;60000&#39;, &#39;None&#39;) insert into Employee (Id, Name, Salary, ManagerId) values (&#39;4&#39;, &#39;Max&#39;, &#39;90000&#39;, &#39;None&#39;)  The Employee table holds all employees including their managers.</description>
    </item>
    
    <item>
      <title>Duplicate Emails</title>
      <link>http://www.hashnopolis.com/post/2018/09/duplicate-emails/</link>
      <pubDate>Wed, 12 Sep 2018 23:55:39 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/duplicate-emails/</guid>
      <description>Write a SQL query to find all duplicate emails in a table named Person.
+----+---------+ | Id | Email | +----+---------+ | 1 | a@b.com | | 2 | c@d.com | | 3 | a@b.com | +----+---------+  For example, your query should return the following for the above table:
+---------+ | Email | +---------+ | a@b.com | +---------+  Note: All emails are in lowercase. Solution:
# Write your MySQL query statement below SELECT email FROM Person WHERE email IN ( SELECT email FROM Person GROUP BY email HAVING COUNT(*) &amp;gt; 1 ) GROUP BY email  </description>
    </item>
    
    <item>
      <title>Combination Sum III</title>
      <link>http://www.hashnopolis.com/post/2018/09/combination-sum-iii/</link>
      <pubDate>Mon, 10 Sep 2018 21:42:37 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/combination-sum-iii/</guid>
      <description>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.
Note:
All numbers will be positive integers. The solution set must not contain duplicate combinations. Example 1:
Input: k = 3, n = 7 Output: [[1,2,4]]  Example 2:
Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]]  Solution:</description>
    </item>
    
    <item>
      <title>Combination Sum</title>
      <link>http://www.hashnopolis.com/post/2018/09/combination-sum/</link>
      <pubDate>Mon, 10 Sep 2018 21:42:01 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/combination-sum/</guid>
      <description>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.
The same repeated number may be chosen from candidates unlimited number of times.
Note:
All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1:
Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ]  Example 2:</description>
    </item>
    
    <item>
      <title>Combinations</title>
      <link>http://www.hashnopolis.com/post/2018/09/combinations/</link>
      <pubDate>Mon, 10 Sep 2018 21:41:18 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/combinations/</guid>
      <description>Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.
Example:
Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]  Solution:
class Solution: def combine(self, n, k): &amp;quot;&amp;quot;&amp;quot; :type n: int :type k: int :rtype: List[List[int]] &amp;quot;&amp;quot;&amp;quot; res = [] nums = list(range(1, n+1)) def iterate(index, tempAns): ans = list(tempAns) if len(ans) &amp;gt; k: return if index &amp;lt; n: ans.</description>
    </item>
    
    <item>
      <title>Combine Two Tables</title>
      <link>http://www.hashnopolis.com/post/2018/09/combine-two-tables/</link>
      <pubDate>Mon, 10 Sep 2018 21:40:30 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/combine-two-tables/</guid>
      <description>Table: Person
+-------------+---------+ | Column Name | Type | +-------------+---------+ | PersonId | int | | FirstName | varchar | | LastName | varchar | +-------------+---------+ PersonId is the primary key column for this table.  Table: Address
+-------------+---------+ | Column Name | Type | +-------------+---------+ | AddressId | int | | PersonId | int | | City | varchar | | State | varchar | +-------------+---------+ AddressId is the primary key column for this table.</description>
    </item>
    
    <item>
      <title>Contains Duplicate</title>
      <link>http://www.hashnopolis.com/post/2018/09/contains-duplicate/</link>
      <pubDate>Mon, 10 Sep 2018 21:39:18 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/contains-duplicate/</guid>
      <description>Given an array of integers, find if the array contains any duplicates.
Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.
Example 1:
Input: [1,2,3,1] Output: true  Example 2:
Input: [1,2,3,4] Output: false  Example 3:
Input: [1,1,1,3,3,4,3,2,4,2] Output: true  Solution:
class Solution: def containsDuplicate(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: bool &amp;quot;&amp;quot;&amp;quot; sortedNums = sorted(nums) for i in range(1, len(nums)): if sortedNums[i] == sortedNums[i-1]: return True return False  </description>
    </item>
    
    <item>
      <title>Climbing Stairs</title>
      <link>http://www.hashnopolis.com/post/2018/09/climbing-stairs/</link>
      <pubDate>Sun, 09 Sep 2018 15:16:10 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/climbing-stairs/</guid>
      <description>You are climbing a stair case. It takes n steps to reach to the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Note: Given n will be a positive integer.
Example 1:
Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps  Example 2:</description>
    </item>
    
    <item>
      <title>Binary Search Tree Iterator</title>
      <link>http://www.hashnopolis.com/post/2018/09/binary-search-tree-iterator/</link>
      <pubDate>Sun, 09 Sep 2018 15:15:09 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/binary-search-tree-iterator/</guid>
      <description>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.
Calling next() will return the next smallest number in the BST.
Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
Solution:
# Definition for a binary tree node # class TreeNode(object): # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Two Sum II Input Array Is Sorted</title>
      <link>http://www.hashnopolis.com/post/2018/09/two-sum-ii-input-array-is-sorted/</link>
      <pubDate>Fri, 07 Sep 2018 23:53:18 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/two-sum-ii-input-array-is-sorted/</guid>
      <description>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.
Note: - Your returned answers (both index1 and index2) are not zero-based. - You may assume that each input would have exactly one solution and you may not use the same element twice.</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock Ii</title>
      <link>http://www.hashnopolis.com/post/2018/09/best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Thu, 06 Sep 2018 23:39:13 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/best-time-to-buy-and-sell-stock-ii/</guid>
      <description>Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).
Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock</title>
      <link>http://www.hashnopolis.com/post/2018/09/best-time-to-buy-and-sell-stock/</link>
      <pubDate>Thu, 06 Sep 2018 23:37:49 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/best-time-to-buy-and-sell-stock/</guid>
      <description>Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.
Note that you cannot sell a stock before you buy one.
Example 1:
Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</description>
    </item>
    
    <item>
      <title>Add Binary</title>
      <link>http://www.hashnopolis.com/post/2018/09/add-binary/</link>
      <pubDate>Wed, 05 Sep 2018 23:48:48 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/add-binary/</guid>
      <description>Given two binary strings, return their sum (also a binary string).
The input strings are both non-empty and contains only characters 1 or 0.
Example 1:
Input: a = &amp;quot;11&amp;quot;, b = &amp;quot;1&amp;quot; Output: &amp;quot;100&amp;quot;  Example 2:
Input: a = &amp;quot;1010&amp;quot;, b = &amp;quot;1011&amp;quot; Output: &amp;quot;10101&amp;quot;  Solution:
class Solution: def addBinary(self, a, b): &amp;quot;&amp;quot;&amp;quot; :type a: str :type b: str :rtype: str &amp;quot;&amp;quot;&amp;quot; result = [] carry = 0 i = len(a)-1 j = len(b)-1 while carry or i &amp;gt;= 0 or j &amp;gt;= 0: total = carry if i &amp;gt;= 0: total += int(a[i]) i -= 1 if j &amp;gt;= 0: total += int(b[j]) j -= 1 result.</description>
    </item>
    
    <item>
      <title>17. Letter Combinations of a Phone Number</title>
      <link>http://www.hashnopolis.com/post/2018/09/17.-letter-combinations-of-a-phone-number/</link>
      <pubDate>Mon, 03 Sep 2018 00:28:45 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/09/17.-letter-combinations-of-a-phone-number/</guid>
      <description>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example:
Input: &amp;quot;23&amp;quot; Output: [&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;].  Note:
Although the above answer is in lexicographical order, your answer could be in any order you want.</description>
    </item>
    
    <item>
      <title>18. 4Sum</title>
      <link>http://www.hashnopolis.com/post/2018/08/18.-4sum/</link>
      <pubDate>Fri, 31 Aug 2018 23:30:43 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/18.-4sum/</guid>
      <description>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note:
The solution set must not contain duplicate quadruplets.
Example:
Given array nums = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]  </description>
    </item>
    
    <item>
      <title>Two Sum</title>
      <link>http://www.hashnopolis.com/post/2018/08/two-sum/</link>
      <pubDate>Wed, 29 Aug 2018 00:44:49 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/two-sum/</guid>
      <description>Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
Example:
Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].  Solution:
# time: o(n) # space: o(n) class Solution: def twoSum(self, nums, target): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :type target: int :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; res = [-1, -1] if nums == None or len(nums) &amp;lt; 2: return res solutionMap = {} for pos in range(len(nums) - 1): if (target - nums[pos]) in solutionMap: res[0] = solutionMap[target - nums[pos]] res[1] = pos break solutionMap[nums[pos]] = pos return res  </description>
    </item>
    
    <item>
      <title>Conditional Render in React</title>
      <link>http://www.hashnopolis.com/post/2018/08/conditional-render-in-react/</link>
      <pubDate>Tue, 28 Aug 2018 23:31:12 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/conditional-render-in-react/</guid>
      <description>In react, sometimes we need to render a component based on some flag, for example, we need to display a different set of information to the admin users than the normal users. We have a prop called isAdmin
render () { const { isAdmin } = this.props return ( &amp;lt;div&amp;gt; { isAdmin ? &amp;lt;CustomeComponent {...propSetA} / &amp;gt; : &amp;lt;CustomeComponent {...propSetB} / &amp;gt; } &amp;lt;/div&amp;gt; ) }  Looks good right, but there is one problem.</description>
    </item>
    
    <item>
      <title>16. 3sum Closest</title>
      <link>http://www.hashnopolis.com/post/2018/08/16.-3sum-closest/</link>
      <pubDate>Mon, 27 Aug 2018 23:30:43 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/16.-3sum-closest/</guid>
      <description>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.
Example:
Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</description>
    </item>
    
    <item>
      <title>15. 3sum</title>
      <link>http://www.hashnopolis.com/post/2018/08/15.-3sum/</link>
      <pubDate>Mon, 27 Aug 2018 23:29:18 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/15.-3sum/</guid>
      <description>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
Note:
The solution set must not contain duplicate triplets.
Example:
Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ]  Solution:</description>
    </item>
    
    <item>
      <title>57. Insert Interval</title>
      <link>http://www.hashnopolis.com/post/2018/08/57.-insert-interval/</link>
      <pubDate>Sun, 26 Aug 2018 00:43:48 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/57.-insert-interval/</guid>
      <description>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).
You may assume that the intervals were initially sorted according to their start times.
Example 1:
Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]]  Example 2:
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].  Solution:
# Definition for an interval. # class Interval: # def __init__(self, s=0, e=0): # self.</description>
    </item>
    
    <item>
      <title>56. Merge Intervals</title>
      <link>http://www.hashnopolis.com/post/2018/08/56.-merge-intervals/</link>
      <pubDate>Fri, 24 Aug 2018 02:19:05 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/56.-merge-intervals/</guid>
      <description>Given a collection of intervals, merge all overlapping intervals.
Example 1:
Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].  Example 2:
Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping.  Solution:
# Definition for an interval. # class Interval: # def __init__(self, s=0, e=0): # self.start = s # self.end = e class Solution: def merge(self, intervals): &amp;quot;&amp;quot;&amp;quot; :type intervals: List[Interval] :rtype: List[Interval] &amp;quot;&amp;quot;&amp;quot; intervals.</description>
    </item>
    
    <item>
      <title>80. Remove Duplicates From Sorted Array II</title>
      <link>http://www.hashnopolis.com/post/2018/08/80.-remove-duplicates-from-sorted-array-ii/</link>
      <pubDate>Fri, 24 Aug 2018 00:48:48 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/80.-remove-duplicates-from-sorted-array-ii/</guid>
      <description>Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Example 1:
Given nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</description>
    </item>
    
    <item>
      <title>Remove Duplicates From Sorted Array</title>
      <link>http://www.hashnopolis.com/post/2018/08/remove-duplicates-from-sorted-array/</link>
      <pubDate>Thu, 23 Aug 2018 23:52:17 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/remove-duplicates-from-sorted-array/</guid>
      <description>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Example 1:
Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn&#39;t matter what you leave beyond the returned length.</description>
    </item>
    
    <item>
      <title>4. Median of Two Sorted Arrays</title>
      <link>http://www.hashnopolis.com/post/2018/08/4.-median-of-two-sorted-arrays/</link>
      <pubDate>Tue, 21 Aug 2018 20:54:32 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/4.-median-of-two-sorted-arrays/</guid>
      <description>There are two sorted arrays nums1 and nums2 of size m and n respectively.
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
You may assume nums1 and nums2 cannot be both empty.
Example 1: nums1 = [1, 3] nums2 = [2]  The median is 2.0
Example 2: nums1 = [1, 2] nums2 = [3, 4]  The median is (2 + 3)/2 = 2.</description>
    </item>
    
    <item>
      <title>Remove Nth Node From End of List</title>
      <link>http://www.hashnopolis.com/post/2018/08/remove-nth-node-from-end-of-list/</link>
      <pubDate>Mon, 20 Aug 2018 23:33:38 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/remove-nth-node-from-end-of-list/</guid>
      <description>Given a linked list, remove the n-th node from the end of list and return its head.
Example:
Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.  Note:
Given n will always be valid.
Follow up:
Could you do this in one pass?
Solution:
# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Search in Rotated Sorted Array II</title>
      <link>http://www.hashnopolis.com/post/2018/08/search-in-rotated-sorted-array-ii/</link>
      <pubDate>Wed, 15 Aug 2018 12:50:21 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/08/search-in-rotated-sorted-array-ii/</guid>
      <description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).
You are given a target value to search. If found in the array return true, otherwise return false.
Example 1:
Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true  Example 2:
Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false  Follow up: - This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.</description>
    </item>
    
    <item>
      <title>When You New a Class in JavaScript?</title>
      <link>http://www.hashnopolis.com/post/2018/02/when-you-new-a-class-in-javascript/</link>
      <pubDate>Tue, 13 Feb 2018 15:30:03 +0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/02/when-you-new-a-class-in-javascript/</guid>
      <description>Here is an example of instantiating a class using the new operator:
class Person { constructor(name, age) { this.name = name; this.age = age; } } const asian = new Person(&#39;Alice&#39;, 25); console.log(asian);  As you can see from below, asian is not a class, it is instead, an object:
[object Object] { age: 25, name: &amp;quot;Alice&amp;quot; }  The values of asian are set by the constructor of the Person class.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.hashnopolis.com/post/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.hashnopolis.com/post/1/01/</guid>
      <description>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.
A partially filled sudoku which is valid.
The Sudoku board could be partially filled, where empty cells are filled with the character &#39;.</description>
    </item>
    
  </channel>
</rss>