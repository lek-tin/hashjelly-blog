<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bfs on Hashnopolis</title>
    <link>http://www.hashnopolis.com/tags/bfs/</link>
    <description>Recent content in bfs on Hashnopolis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Hashnopolis</copyright>
    <lastBuildDate>Mon, 17 Feb 2020 23:36:34 -0800</lastBuildDate>
    
	<atom:link href="http://www.hashnopolis.com/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Sliding Puzzle</title>
      <link>http://www.hashnopolis.com/post/2020/02/sliding-puzzle/</link>
      <pubDate>Mon, 17 Feb 2020 23:36:34 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2020/02/sliding-puzzle/</guid>
      <description>On a 2x3 board, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0.
A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.
The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].
Given a puzzle board, return the least number of moves required so that the state of the board is solved.</description>
    </item>
    
    <item>
      <title>Word Ladder Ii</title>
      <link>http://www.hashnopolis.com/post/2019/11/word-ladder-ii/</link>
      <pubDate>Sat, 30 Nov 2019 16:03:43 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/11/word-ladder-ii/</guid>
      <description>Given two words (beginWord and endWord), and a dictionary&amp;rsquo;s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:
 Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note:  Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters.</description>
    </item>
    
    <item>
      <title>Island Perimeter</title>
      <link>http://www.hashnopolis.com/post/2019/09/island-perimeter/</link>
      <pubDate>Fri, 27 Sep 2019 16:50:11 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/09/island-perimeter/</guid>
      <description>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.
Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).
The island doesn&amp;rsquo;t have &amp;ldquo;lakes&amp;rdquo; (water inside that isn&amp;rsquo;t connected to the water around the island). One cell is a square with side length 1.</description>
    </item>
    
    <item>
      <title>Clone Graph</title>
      <link>http://www.hashnopolis.com/post/2019/08/clone-graph/</link>
      <pubDate>Sun, 11 Aug 2019 01:12:12 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/08/clone-graph/</guid>
      <description>Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.
Example: Input: {&amp;quot;$id&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$id&amp;quot;:&amp;quot;2&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;1&amp;quot;},{&amp;quot;$id&amp;quot;:&amp;quot;3&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;2&amp;quot;},{&amp;quot;$id&amp;quot;:&amp;quot;4&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;3&amp;quot;},{&amp;quot;$ref&amp;quot;:&amp;quot;1&amp;quot;}],&amp;quot;val&amp;quot;:4}],&amp;quot;val&amp;quot;:3}],&amp;quot;val&amp;quot;:2},{&amp;quot;$ref&amp;quot;:&amp;quot;4&amp;quot;}],&amp;quot;val&amp;quot;:1} Explanation: Node 1&#39;s value is 1, and it has two neighbors: Node 2 and 4. Node 2&#39;s value is 2, and it has two neighbors: Node 1 and 3. Node 3&#39;s value is 3, and it has two neighbors: Node 2 and 4.</description>
    </item>
    
    <item>
      <title>Word Search II</title>
      <link>http://www.hashnopolis.com/post/2019/04/word-search-ii/</link>
      <pubDate>Mon, 08 Apr 2019 23:50:33 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/04/word-search-ii/</guid>
      <description>Given a 2D board and a list of words from the dictionary, find all words in the board.
Each word must be constructed from letters of sequentially adjacent cell, where &amp;ldquo;adjacent&amp;rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.
Example: Input: board = [ [&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;], [&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;], [&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;], [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;] ] words = [&amp;quot;oath&amp;quot;,&amp;quot;pea&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;rain&amp;quot;] Output: [&amp;quot;eat&amp;quot;,&amp;quot;oath&amp;quot;] Note:  All inputs are consist of lowercase letters a-z.</description>
    </item>
    
    <item>
      <title>The Maze II</title>
      <link>http://www.hashnopolis.com/post/2019/03/the-maze-ii/</link>
      <pubDate>Mon, 18 Mar 2019 20:34:03 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/the-maze-ii/</guid>
      <description>There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won&amp;rsquo;t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.
Given the ball&amp;rsquo;s start position, the destination and the maze, find the shortest distance for the ball to stop at the destination. The distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to the destination (included).</description>
    </item>
    
    <item>
      <title>The Maze</title>
      <link>http://www.hashnopolis.com/post/2019/03/the-maze/</link>
      <pubDate>Sun, 17 Mar 2019 20:18:05 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/the-maze/</guid>
      <description>There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won&amp;rsquo;t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.
Given the ball&amp;rsquo;s start position, the destination and the maze, determine whether the ball could stop at the destination.
The maze is represented by a binary 2D array.</description>
    </item>
    
    <item>
      <title>Snakes and Ladders</title>
      <link>http://www.hashnopolis.com/post/2019/03/snakes-and-ladders/</link>
      <pubDate>Tue, 12 Mar 2019 01:16:31 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2019/03/snakes-and-ladders/</guid>
      <description>On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row. For example, for a 6 x 6 board, the numbers are written as follows: You start on square 1 of the board (which is always in the last row and first column). Each move, starting from square x, consists of the following:</description>
    </item>
    
    <item>
      <title>Validate Binary Search Tree</title>
      <link>http://www.hashnopolis.com/post/2018/11/validate-binary-search-tree/</link>
      <pubDate>Sat, 10 Nov 2018 22:50:21 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/11/validate-binary-search-tree/</guid>
      <description>Given a binary tree, determine if it is a valid binary search tree (BST).
Assume a BST is defined as follows:
 The left subtree of a node contains only nodes with keys less than the node&amp;rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node&amp;rsquo;s key. Both the left and right subtrees must also be binary search trees.  Example 1 Input: 2 / \ 1 3 Output: true Example 2  5 / \ 1 4 / \ 3 6 Output: false Explanation The input is: [5,1,4,null,null,3,6].</description>
    </item>
    
    <item>
      <title>Word Ladder</title>
      <link>http://www.hashnopolis.com/post/2018/10/word-ladder/</link>
      <pubDate>Sat, 27 Oct 2018 01:05:07 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/word-ladder/</guid>
      <description>Given two words (beginWord and endWord), and a dictionary&amp;rsquo;s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:
 Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word.  Note  Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters.</description>
    </item>
    
    <item>
      <title>Word Break</title>
      <link>http://www.hashnopolis.com/post/2018/10/word-break/</link>
      <pubDate>Wed, 10 Oct 2018 23:57:15 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/word-break/</guid>
      <description>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.
Note  The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.  Example 1 Input: s = &amp;quot;leetcode&amp;quot;, wordDict = [&amp;quot;leet&amp;quot;, &amp;quot;code&amp;quot;] Output: true Explanation: Return true because &amp;quot;leetcode&amp;quot; can be segmented as &amp;quot;leet code&amp;quot;.</description>
    </item>
    
    <item>
      <title>Number of Islands</title>
      <link>http://www.hashnopolis.com/post/2018/10/number-of-islands/</link>
      <pubDate>Tue, 09 Oct 2018 23:52:32 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/2018/10/number-of-islands/</guid>
      <description>Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
Example 1 Input: 11110 11010 11000 00000 Output: 1 Example 2 Input: 11000 11000 00100 00011 Output: 3 DFS
Solution class Solution: def numIslands(self, grid): &amp;#34;&amp;#34;&amp;#34; :type grid: List[List[str]] :rtype: int &amp;#34;&amp;#34;&amp;#34; # Edge cases if not grid or len(grid) == 0 or len(grid[0]) == 0: return 0 rows = len(grid) cols = len(grid[0]) count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == &amp;#34;1&amp;#34;: count += 1 self.</description>
    </item>
    
  </channel>
</rss>