<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>union-find on Hashnopolis</title>
    <link>http://www.hashnopolis.com/tags/union-find/</link>
    <description>Recent content in union-find on Hashnopolis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Hashnopolis</copyright>
    <lastBuildDate>Wed, 01 Apr 2020 21:23:13 -0700</lastBuildDate>
    
	<atom:link href="http://www.hashnopolis.com/tags/union-find/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Smallest String With Swaps</title>
      <link>http://www.hashnopolis.com/post/smallest-string-with-swaps/</link>
      <pubDate>Wed, 01 Apr 2020 21:23:13 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/smallest-string-with-swaps/</guid>
      <description>You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string.
You can swap the characters at any pair of indices in the given pairs any number of times.
Return the lexicographically smallest string that s can be changed to after using the swaps.
Example 1 Input: s = &amp;quot;dcab&amp;quot;, pairs = [[0,3],[1,2]] Output: &amp;quot;bacd&amp;quot; Explaination: Swap s[0] and s[3], s = &amp;quot;bcad&amp;quot; Swap s[1] and s[2], s = &amp;quot;bacd&amp;quot; Example 2 Input: s = &amp;quot;dcab&amp;quot;, pairs = [[0,3],[1,2],[0,2]] Output: &amp;quot;abcd&amp;quot; Explaination: Swap s[0] and s[3], s = &amp;quot;bcad&amp;quot; Swap s[0] and s[2], s = &amp;quot;acbd&amp;quot; Swap s[1] and s[2], s = &amp;quot;abcd&amp;quot; Example 3 Input: s = &amp;quot;cba&amp;quot;, pairs = [[0,1],[1,2]] Output: &amp;quot;abc&amp;quot; Explaination: Swap s[0] and s[1], s = &amp;quot;bca&amp;quot; Swap s[1] and s[2], s = &amp;quot;bac&amp;quot; Swap s[0] and s[1], s = &amp;quot;abc&amp;quot; Constraints  1 &amp;lt;= s.</description>
    </item>
    
    <item>
      <title>Evaluate Division</title>
      <link>http://www.hashnopolis.com/post/evaluate-division/</link>
      <pubDate>Sat, 21 Mar 2020 21:57:58 -0700</pubDate>
      
      <guid>http://www.hashnopolis.com/post/evaluate-division/</guid>
      <description>Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.
Example Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a = ?, a / e = ?</description>
    </item>
    
    <item>
      <title>Number of Islands Ii</title>
      <link>http://www.hashnopolis.com/post/number-of-islands-ii/</link>
      <pubDate>Fri, 06 Mar 2020 20:24:47 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/number-of-islands-ii/</guid>
      <description>A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</description>
    </item>
    
    <item>
      <title>Redundant Connection</title>
      <link>http://www.hashnopolis.com/post/redundant-connection/</link>
      <pubDate>Mon, 02 Mar 2020 15:48:06 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/redundant-connection/</guid>
      <description>In this problem, a tree is an undirected graph that is connected and has no cycles.
The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.
The resulting graph is given as a 2D-array of edges.</description>
    </item>
    
    <item>
      <title>Largest Component Size by Common Factor</title>
      <link>http://www.hashnopolis.com/post/largest-component-size-by-common-factor/</link>
      <pubDate>Tue, 11 Feb 2020 23:25:11 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/largest-component-size-by-common-factor/</guid>
      <description>Given a non-empty array of unique positive integers A, consider the following graph:
 There are A.length nodes, labelled A[0] to A[A.length - 1]; There is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.  Return the size of the largest connected component in the graph.
Example 1 Input: [4,6,15,35] Output: 4 Example 2 Input: [20,50,9,63] Output: 2 Example 3  Input: [2,3,6,7,4,12,21,39] Output: 8 Note  1 &amp;lt;= A.</description>
    </item>
    
    <item>
      <title>Longest Consecutive Sequence</title>
      <link>http://www.hashnopolis.com/post/longest-consecutive-sequence/</link>
      <pubDate>Tue, 10 Sep 2019 12:01:01 -0800</pubDate>
      
      <guid>http://www.hashnopolis.com/post/longest-consecutive-sequence/</guid>
      <description>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
Your algorithm should run in O(n) complexity.
Example Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Solution # Time: `O(n)` class Solution: def longestConsecutive(self, nums: List[int]) -&amp;gt; int: # Count occurence of nums mapping = {} for num in nums: mapping[num] = True # init longest length longest = 0 # iterate over nums for num in nums: if num in mapping: # num exists in mapping =&amp;gt; init l = 1 l = 1 # num was counted, so we delete num del mapping[num] left, right = num-1, num+1 # Move left while left in mapping: # left was counted, so we delete left del mapping[left] left -= 1 l += 1 # Move right while right in mapping: # right was counted, so we delete right del mapping[right] right += 1 l += 1 # Update longest longest = max(longest, l) return longest </description>
    </item>
    
  </channel>
</rss>